[{"/Users/philippebaillargeon/Documents/AI/chess-app/src/index.tsx":"1","/Users/philippebaillargeon/Documents/AI/chess-app/src/reportWebVitals.ts":"2","/Users/philippebaillargeon/Documents/AI/chess-app/src/App.tsx":"3","/Users/philippebaillargeon/Documents/AI/chess-app/src/components/Chessboard/Chessboard.tsx":"4","/Users/philippebaillargeon/Documents/AI/chess-app/src/Constants.ts":"5","/Users/philippebaillargeon/Documents/AI/chess-app/src/referee/Referee.ts":"6","/Users/philippebaillargeon/Documents/AI/chess-app/src/components/Tile/Tile.tsx":"7","/Users/philippebaillargeon/Documents/AI/chess-app/src/referee/rules/index.ts":"8","/Users/philippebaillargeon/Documents/AI/chess-app/src/referee/rules/KnightRules.ts":"9","/Users/philippebaillargeon/Documents/AI/chess-app/src/referee/rules/BishopRules.ts":"10","/Users/philippebaillargeon/Documents/AI/chess-app/src/referee/rules/QueenRules.ts":"11","/Users/philippebaillargeon/Documents/AI/chess-app/src/referee/rules/RookRules.ts":"12","/Users/philippebaillargeon/Documents/AI/chess-app/src/referee/rules/KingRules.ts":"13","/Users/philippebaillargeon/Documents/AI/chess-app/src/referee/rules/PawnRules.ts":"14","/Users/philippebaillargeon/Documents/AI/chess-app/src/referee/rules/GeneralRules.ts":"15","/Users/philippebaillargeon/Documents/AI/chess-app/src/Engine/Engine.ts":"16","/Users/philippebaillargeon/Documents/AI/chess-app/src/Engine/OnDropObservable.ts":"17","/Users/philippebaillargeon/Documents/AI/chess-app/src/components/Chessboard/ChessboardHelper.ts":"18"},{"size":500,"mtime":1638977559000,"results":"19","hashOfConfig":"20"},{"size":425,"mtime":1638977559000,"results":"21","hashOfConfig":"20"},{"size":215,"mtime":1646240381487,"results":"22","hashOfConfig":"20"},{"size":11284,"mtime":1649045176762,"results":"23","hashOfConfig":"20"},{"size":5612,"mtime":1648149440176,"results":"24","hashOfConfig":"20"},{"size":10352,"mtime":1649036779011,"results":"25","hashOfConfig":"20"},{"size":547,"mtime":1646240487938,"results":"26","hashOfConfig":"20"},{"size":178,"mtime":1638977559000,"results":"27","hashOfConfig":"20"},{"size":1182,"mtime":1638977559000,"results":"28","hashOfConfig":"20"},{"size":2836,"mtime":1638977559000,"results":"29","hashOfConfig":"20"},{"size":1009,"mtime":1638977559000,"results":"30","hashOfConfig":"20"},{"size":1397,"mtime":1646361973038,"results":"31","hashOfConfig":"20"},{"size":1008,"mtime":1638977559000,"results":"32","hashOfConfig":"20"},{"size":1763,"mtime":1646507542604,"results":"33","hashOfConfig":"20"},{"size":896,"mtime":1638977559000,"results":"34","hashOfConfig":"20"},{"size":6857,"mtime":1649038981792,"results":"35","hashOfConfig":"20"},{"size":240,"mtime":1648772466815,"results":"36","hashOfConfig":"20"},{"size":1370,"mtime":1648782736452,"results":"37","hashOfConfig":"20"},{"filePath":"38","messages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},"qecjsu",{"filePath":"41","messages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"43","messages":"44","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"45","messages":"46","errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"47","messages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"49","messages":"50","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"51","usedDeprecatedRules":"40"},{"filePath":"52","messages":"53","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"54","messages":"55","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"56","messages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"58","messages":"59","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"60","messages":"61","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"62","messages":"63","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"64","messages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"66","messages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"68","usedDeprecatedRules":"40"},{"filePath":"69","messages":"70","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"71","messages":"72","errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"73","usedDeprecatedRules":"40"},{"filePath":"74","messages":"75","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"76","messages":"77","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"78","usedDeprecatedRules":"40"},"/Users/philippebaillargeon/Documents/AI/chess-app/src/index.tsx",[],["79","80"],"/Users/philippebaillargeon/Documents/AI/chess-app/src/reportWebVitals.ts",[],"/Users/philippebaillargeon/Documents/AI/chess-app/src/App.tsx",[],"/Users/philippebaillargeon/Documents/AI/chess-app/src/components/Chessboard/Chessboard.tsx",["81","82","83","84","85","86","87","88","89","90","91","92","93"],"/Users/philippebaillargeon/Documents/AI/chess-app/src/Constants.ts",[],"/Users/philippebaillargeon/Documents/AI/chess-app/src/referee/Referee.ts",["94","95","96","97","98"],"import { off } from \"process\";\nimport {\n  PieceType,\n  TeamType,\n  Piece,\n  Position,\n  samePosition,\n  Move,\n} from \"../Constants\";\n\nimport {\n  pawnMove,\n  knightMove,\n  bishopMove,\n  rookMove,\n  queenMove,\n  kingMove,\n} from \"./rules\";\n\nexport default class Referee {\n  state: Piece[] = [];\n\n  isEnPassantMove(\n    initialPosition: Position,\n    desiredPosition: Position,\n    type: PieceType,\n    team: TeamType,\n    boardState: Piece[]\n  ) {\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n\n    if (type === PieceType.PAWN) {\n      if (\n        (desiredPosition.x - initialPosition.x === -1 ||\n          desiredPosition.x - initialPosition.x === 1) &&\n        desiredPosition.y - initialPosition.y === pawnDirection\n      ) {\n        const piece = boardState.find(\n          (p) =>\n            p.position.x === desiredPosition.x &&\n            p.position.y === desiredPosition.y - pawnDirection &&\n            p.enPassant\n        );\n        if (piece) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  //TODO\n  //Add check!\n  //Add checkmate!\n  //Add stalemate!\n  isValidMove(\n    initialPosition: Position,\n    desiredPosition: Position,\n    type: PieceType,\n    team: TeamType,\n    boardState: Piece[],\n    turn: boolean,\n    depth: number\n  ) {\n    let validMove = false;\n    let tempBoard: Piece[];\n    let kingPrevPos = {\n      x: 10,\n      y: 10,\n    };\n\n    if (this.checkTurn(team, turn)) {\n      // console.log(\"checkturn\");\n      return false;\n    }\n\n    switch (type) {\n      case PieceType.PAWN:\n        validMove = pawnMove(\n          initialPosition,\n          desiredPosition,\n          team,\n          boardState\n        );\n        break;\n      case PieceType.KNIGHT:\n        validMove = knightMove(\n          initialPosition,\n          desiredPosition,\n          team,\n          boardState\n        );\n        break;\n      case PieceType.BISHOP:\n        validMove = bishopMove(\n          initialPosition,\n          desiredPosition,\n          team,\n          boardState\n        );\n        break;\n      case PieceType.ROOK:\n        validMove = rookMove(\n          initialPosition,\n          desiredPosition,\n          team,\n          boardState\n        );\n        break;\n      case PieceType.QUEEN:\n        validMove = queenMove(\n          initialPosition,\n          desiredPosition,\n          team,\n          boardState\n        );\n        break;\n      case PieceType.KING:\n        validMove = kingMove(\n          initialPosition,\n          desiredPosition,\n          team,\n          boardState\n        );\n\n        if (depth < 1 && validMove) {\n          tempBoard = JSON.parse(JSON.stringify(boardState));\n          tempBoard.map((piece) => {\n            if (samePosition(piece.position, initialPosition)) {\n              piece.position = desiredPosition;\n              kingPrevPos.x = piece.position.x;\n              kingPrevPos.y = piece.position.y;\n              if (\n                this.kingMoveToInvalidSquare(\n                  team,\n                  desiredPosition,\n                  tempBoard,\n                  turn,\n                  depth\n                )\n              ) {\n                validMove = false;\n              }\n            }\n          });\n        }\n        break;\n    }\n\n    if (validMove && depth < 1) {\n      tempBoard = JSON.parse(JSON.stringify(boardState));\n      tempBoard.map((piece) => {\n        if (samePosition(piece.position, initialPosition)) {\n          piece.position = desiredPosition;\n          tempBoard = this.removeCapturedPiece(piece, tempBoard);\n          if (this.isInCheck(tempBoard, turn)) {\n            validMove = false;\n          }\n        }\n      });\n    }\n    return validMove;\n  }\n\n  removeCapturedPiece(piece: Piece, pieces: Piece[]) {\n    let p = null;\n    for (const piec of pieces) {\n      if (\n        samePosition(piec.position, piece.position) &&\n        piece.team !== piec.team\n      ) {\n        p = piec;\n      }\n    }\n    if (p !== null) {\n      // console.log(\"captured piece \", p);\n      let idx = pieces.indexOf(p);\n      if (idx !== -1) {\n        // console.log(\"p jamais égale \", idx);\n        pieces.splice(idx, 1);\n      }\n    }\n    return pieces;\n  }\n\n  isInCheck(pieces: Piece[], turn: boolean) {\n    // Find the king\n    let king = this.getKing(pieces, turn);\n    for (const piece of pieces) {\n      // Check if enemy pieces can check the king\n      if (piece?.team !== king?.team) {\n        if (king !== null) {\n          if (\n            this.isValidMove(\n              piece.position,\n              { x: king.position.x, y: king.position.y },\n              piece.type,\n              piece.team,\n              pieces,\n              !turn,\n              1\n            )\n          ) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  kingMoveToInvalidSquare(\n    team: TeamType,\n    desiredPosition: Position,\n    board: Piece[],\n    turn: boolean,\n    depth: number\n  ): boolean {\n    const currentTurn = !turn;\n\n    const king = this.getKing(board, turn);\n    let p = null;\n    if (king !== null) {\n      p = this.removeCapturedPiece(king, board);\n    }\n\n    for (const piece of board) {\n      if (piece.team !== team && depth < 1) {\n        if (\n          this.isValidMove(\n            piece.position,\n            desiredPosition,\n            piece.type,\n            piece.team,\n            board,\n            currentTurn,\n            depth + 1\n          )\n        ) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  checkCastling(king: Piece, pieces: Piece[], side: number, turn: boolean) {\n    const row = king.position.y;\n    let rook = null;\n\n    // Castling right\n    if (side < 0) {\n      for (const piece of pieces) {\n        // Check if attacks between rook and king\n        if (piece.team !== king.team) {\n          for (let i = 0; i < 3; i++) {\n            if (\n              this.isValidMove(\n                piece.position,\n                { x: king.position.x + i, y: king.position.y },\n                piece.type,\n                piece.team,\n                pieces,\n                !turn,\n                1\n              )\n            ) {\n              return false;\n            }\n          }\n        }\n\n        if (piece.type === PieceType.ROOK && piece.team === king.team) {\n          if (piece.position.x === 7) {\n            rook = piece;\n            if (piece.hasMoved) {\n              return false;\n            }\n          }\n        }\n\n        // Check if pieces between rook and king\n        if (samePosition(piece.position, { x: 5, y: row })) {\n          return false;\n        } else if (samePosition(piece.position, { x: 6, y: row })) {\n          return false;\n        }\n      }\n    }\n    // Castling left\n    else {\n      for (const piece of pieces) {\n        if (piece.team !== king.team) {\n          for (let i = 0; i < 4; i++) {\n            if (\n              this.isValidMove(\n                piece.position,\n                { x: king.position.x - i, y: king.position.y },\n                piece.type,\n                piece.team,\n                pieces,\n                !turn,\n                1\n              )\n            ) {\n              return false;\n            }\n          }\n        }\n\n        if (piece.type === PieceType.ROOK && piece.team === king.team) {\n          if (piece.position.x === 0) {\n            rook = piece;\n            if (piece.hasMoved) {\n              return false;\n            }\n          }\n        }\n\n        if (samePosition(piece.position, { x: 1, y: row })) {\n          return false;\n        } else if (samePosition(piece.position, { x: 2, y: row })) {\n          return false;\n        } else if (samePosition(piece.position, { x: 3, y: row })) {\n          return false;\n        }\n      }\n    }\n\n    // If rook is not null, it means we found the rook.\n    if (rook !== null) {\n      return true;\n    }\n    return false;\n  }\n\n  getKing(pieces: Piece[], turn: boolean) {\n    for (const piece of pieces) {\n      if (piece?.type === PieceType.KING) {\n        if (turn) {\n          if (piece.team === TeamType.OUR) {\n            return piece;\n          }\n        } else {\n          if (piece.team === TeamType.OPPONENT) {\n            return piece;\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  checkTurn(team: TeamType, turn: boolean) {\n    if (\n      (team === TeamType.OUR && turn === false) ||\n      (team === TeamType.OPPONENT && turn === true)\n    ) {\n      // If true then it is NOT your turn\n      return true;\n    }\n  }\n\n  isCheckmate(pieces: Piece[], turn: boolean) {\n    // Potential draw\n    if (pieces.length === 2) {\n      return \"draw\";\n    } else if (pieces.length < 5) {\n      let countWhite = 0;\n      let countBlack = 0;\n      for (const piece of pieces) {\n        if (piece.type !== PieceType.KING) {\n          if (\n            piece.type !== PieceType.PAWN &&\n            piece.type !== PieceType.QUEEN &&\n            piece.type !== PieceType.ROOK\n          ) {\n            if (piece.team === TeamType.OUR) {\n              countWhite++;\n            } else {\n              countBlack++;\n            }\n          }\n        }\n      }\n      if (countWhite < 2) {\n        return \"draw\";\n      } else if (countBlack < 2) {\n        return \"draw\";\n      }\n    }\n\n    for (const piece of pieces) {\n      // white's turn\n      if (turn && piece.team === TeamType.OUR) {\n        for (let i = 0; i < 8; i++) {\n          for (let j = 0; j < 8; j++) {\n            if (\n              this.isValidMove(\n                piece.position,\n                { x: i, y: j },\n                piece.type,\n                piece.team,\n                pieces,\n                turn,\n                0\n              )\n            ) {\n              return \"false\";\n            }\n          }\n        }\n      } else if (!turn && piece.team === TeamType.OPPONENT) {\n        for (let i = 0; i < 8; i++) {\n          for (let j = 0; j < 8; j++) {\n            if (\n              this.isValidMove(\n                piece.position,\n                { x: i, y: j },\n                piece.type,\n                piece.team,\n                pieces,\n                turn,\n                0\n              )\n            ) {\n              return \"false\";\n            }\n          }\n        }\n      }\n    }\n\n    if (this.isInCheck(pieces, turn)) {\n      return \"true\";\n    } else {\n      return \"stalemate\";\n    }\n  }\n}\n","/Users/philippebaillargeon/Documents/AI/chess-app/src/components/Tile/Tile.tsx",[],"/Users/philippebaillargeon/Documents/AI/chess-app/src/referee/rules/index.ts",[],"/Users/philippebaillargeon/Documents/AI/chess-app/src/referee/rules/KnightRules.ts",[],"/Users/philippebaillargeon/Documents/AI/chess-app/src/referee/rules/BishopRules.ts",[],"/Users/philippebaillargeon/Documents/AI/chess-app/src/referee/rules/QueenRules.ts",[],"/Users/philippebaillargeon/Documents/AI/chess-app/src/referee/rules/RookRules.ts",[],"/Users/philippebaillargeon/Documents/AI/chess-app/src/referee/rules/KingRules.ts",[],"/Users/philippebaillargeon/Documents/AI/chess-app/src/referee/rules/PawnRules.ts",["99"],"import { Piece, PieceType, Position, TeamType } from \"../../Constants\";\nimport { tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const pawnMove = (initialPosition: Position, desiredPosition: Position, team: TeamType, boardState: Piece[]): boolean => {\n    const specialRow = team === TeamType.OUR ? 1 : 6;\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n\n    // if(test) console.log('works')\n\n    //MOVEMENT LOGIC\n    if (\n      initialPosition.x === desiredPosition.x &&\n      initialPosition.y === specialRow &&\n      desiredPosition.y - initialPosition.y === 2 * pawnDirection\n    ) {\n      if (\n        !tileIsOccupied(desiredPosition, boardState) &&\n        !tileIsOccupied(\n          { x: desiredPosition.x, y: desiredPosition.y - pawnDirection },\n          boardState\n        )\n      ) {\n\n        return true;\n      }\n    } else if (\n      initialPosition.x === desiredPosition.x &&\n      desiredPosition.y - initialPosition.y === pawnDirection\n    ) {\n      if (!tileIsOccupied(desiredPosition, boardState)) {\n        // console.log('ffffffffffffffffff')\n        return true;\n      }\n    }\n    //ATTACK LOGIC\n    else if (\n      desiredPosition.x - initialPosition.x === -1 &&\n      desiredPosition.y - initialPosition.y === pawnDirection\n    ) {\n      //ATTACK IN UPPER OR BOTTOM LEFT CORNER\n      if (tileIsOccupiedByOpponent(desiredPosition, boardState, team)) {\n        return true;\n      }\n    } else if (\n      desiredPosition.x - initialPosition.x === 1 &&\n      desiredPosition.y - initialPosition.y === pawnDirection\n    ) {\n      //ATTACK IN THE UPPER OR BOTTOM RIGHT CORNER\n      if (tileIsOccupiedByOpponent(desiredPosition, boardState, team)) {    \n        return true;\n      }\n    }\n\n    return false;\n  }","/Users/philippebaillargeon/Documents/AI/chess-app/src/referee/rules/GeneralRules.ts",[],"/Users/philippebaillargeon/Documents/AI/chess-app/src/Engine/Engine.ts",["100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115"],"import Referee from \"../referee/Referee\";\nimport {\n  PieceType,\n  TeamType,\n  Piece,\n  Position,\n  samePosition,\n  Move,\n} from \"../Constants\";\n\nimport {\n  pawnMove,\n  knightMove,\n  bishopMove,\n  rookMove,\n  queenMove,\n  kingMove,\n} from \"../referee/rules\";\n\ninterface AlphaBetaMove {\n  piece: Piece;\n  position: Position;\n  value: number;\n}\n\nexport default class Engine {\n  ref: Referee;\n\n  constructor(ref: Referee) {\n    this.ref = ref;\n  }\n\n  play(pieces: Piece[]): Piece[] {\n    const bestMove = this.alphaBeta(\n      // bestMove,\n      pieces,\n      2,\n      -Math.pow(10, 1000),\n      Math.pow(10, 1000),\n      TeamType.OPPONENT\n    );\n    console.log(\"the best move is: \", bestMove);\n    if (bestMove.value == 0) {\n      let moves: any = [];\n      let move: any = null;\n      let randomPiece: any = null;\n      while (moves.length < 1) {\n        randomPiece = pieces[Math.floor(Math.random() * pieces.length)];\n        // console.log(\"the random piece move \", randomPiece);\n        moves = this.getMoves(randomPiece, pieces, true);\n        move = moves[Math.floor(Math.random() * moves.length)];\n      }\n      if (move != null) {\n        console.log(\"the move choosen \", move);\n        for (const piece of pieces) {\n          if (piece.position == randomPiece.position) {\n            console.log(\"the piece \", piece);\n            console.log(\"the position \", move);\n            piece.position = move;\n            this.ref.removeCapturedPiece(piece, pieces);\n            return pieces;\n          }\n        }\n      }\n      // moves[Math.floor(Math.random() * moves.length)];\n    } else {\n      if (pieces.length > 0) {\n        for (const piece of pieces) {\n          console.log(piece.position);\n          if (piece.position === bestMove.piece.position) {\n            piece.position = bestMove.position;\n            this.ref.removeCapturedPiece(piece, pieces);\n            return pieces;\n          }\n        }\n      }\n    }\n    return pieces;\n  }\n\n  alphaBeta(\n    // bestMove: AlphaBetaMove,\n    pieces: Piece[],\n    depth: number,\n    a: number,\n    b: number,\n    maximizingPlayer: TeamType\n  ): AlphaBetaMove {\n    let bestMov = <AlphaBetaMove>(\n      (<unknown>{ piece: null, position: null, value: null })\n    );\n    if (depth === 0) {\n      const value = this.evaluation(pieces);\n      // if (value === 1) {\n      //   // console.log(\"knight took ? \", pieces[1]);\n      // }\n      let _eval = <AlphaBetaMove>(\n        (<unknown>{ piece: null, position: null, value: value })\n      );\n      // console.log(\"the eval is: \", _eval);\n      return _eval;\n    }\n    if (maximizingPlayer === TeamType.OPPONENT) {\n      let maxEval = -1 * Math.pow(10, 1000); // -Infinite\n      for (const piece of pieces) {\n        if (piece.team === TeamType.OPPONENT) {\n          const moves = this.getMoves(piece, pieces, true);\n          for (const move of moves) {\n            let tempPieces = JSON.parse(JSON.stringify(pieces));\n            tempPieces.map((p: Piece) => {\n              if (samePosition(p.position, piece.position)) {\n                p.position = move;\n                tempPieces = this.ref.removeCapturedPiece(p, tempPieces);\n              }\n            });\n            const newEval = this.alphaBeta(\n              tempPieces,\n              depth - 1,\n              a,\n              b,\n              TeamType.OUR\n            );\n            if (maxEval < newEval.value) {\n              // console.log(\"found a better move \", move);\n              // bestMov = newEval;\n              bestMov.piece = piece;\n              bestMov.position = move;\n              bestMov.value = newEval.value;\n              maxEval = newEval.value;\n            }\n            // maxEval = Math.max(maxEval, newEval.value);\n            a = Math.max(a, newEval.value);\n            if (b <= a) {\n              break;\n            }\n          }\n        }\n      }\n      return bestMov;\n    } else {\n      let minEval = Math.pow(10, 1000);\n      for (const piece of pieces) {\n        if (piece.team === TeamType.OUR) {\n          const moves = this.getMoves(piece, pieces, false);\n          for (const move of moves) {\n            let tempPieces = JSON.parse(JSON.stringify(pieces));\n            tempPieces.map((p: Piece) => {\n              if (samePosition(p.position, piece.position)) {\n                p.position = move;\n                // console.log(\"before capture: \", tempPieces.length);\n                tempPieces = this.ref.removeCapturedPiece(p, tempPieces);\n                // console.log(\"after capture \", tempPieces.length);\n              }\n            });\n            const newEval = this.alphaBeta(\n              tempPieces,\n              depth - 1,\n              a,\n              b,\n              TeamType.OPPONENT\n            );\n            if (minEval > newEval.value) {\n              // console.log(\"found a better move\");\n              // bestMov = newEval;\n              bestMov.piece = piece;\n              bestMov.position = move;\n              bestMov.value = newEval.value;\n              minEval = newEval.value;\n            }\n            b = Math.min(b, newEval.value);\n            if (b <= a) {\n              break;\n            }\n          }\n        }\n      }\n      return bestMov;\n    }\n  }\n\n  getMoves(piece: Piece, pieces: Piece[], turn: boolean): Position[] {\n    let movesList: Position[];\n    movesList = [];\n    for (let i = 0; i < 8; i++) {\n      for (let j = 0; j < 8; j++) {\n        const move = <Position>{ x: i, y: j };\n        if (\n          this.ref.isValidMove(\n            piece.position,\n            move,\n            piece.type,\n            piece.team,\n            pieces,\n            !turn,\n            0\n          )\n        ) {\n          movesList.push({ x: i, y: j });\n        }\n      }\n    }\n    return movesList;\n  }\n\n  evaluation(pieces: Piece[]): number {\n    let counter = 0;\n    for (const piece of pieces) {\n      if (piece.team === TeamType.OPPONENT) {\n        switch (piece.type) {\n          case PieceType.BISHOP:\n            counter += 3;\n            break;\n          case PieceType.KNIGHT:\n            counter += 3;\n            break;\n          case PieceType.PAWN:\n            counter += 1;\n            break;\n          case PieceType.QUEEN:\n            counter += 9;\n            break;\n          case PieceType.ROOK:\n            counter += 5;\n            break;\n        }\n      } else {\n        switch (piece.type) {\n          case PieceType.BISHOP:\n            counter -= 3;\n            break;\n          case PieceType.KNIGHT:\n            counter -= 3;\n            break;\n          case PieceType.PAWN:\n            counter -= 1;\n            break;\n          case PieceType.QUEEN:\n            counter -= 9;\n            break;\n          case PieceType.ROOK:\n            counter -= 5;\n            break;\n        }\n      }\n    }\n    // console.log(\"La différence de pointage: \", counter);\n    return counter;\n  }\n}\n","/Users/philippebaillargeon/Documents/AI/chess-app/src/Engine/OnDropObservable.ts",[],"/Users/philippebaillargeon/Documents/AI/chess-app/src/components/Chessboard/ChessboardHelper.ts",["116"],"import { Piece, PieceType, Position, samePosition } from \"../../Constants\";\nimport Referee from \"../../referee/Referee\";\n\nexport default class ChessboardHelper {\n  castlingReduce(\n    pieces: Piece[],\n    castling: any,\n    tempKingPosX: number,\n    tempKingPosY: number,\n    grabPosition: Position,\n    x: number,\n    y: number\n  ) {\n    pieces.reduce((results, piece) => {\n      if (castling.side === \"right\") {\n        if (\n          samePosition(piece.position, {\n            x: tempKingPosX + 3,\n            y: tempKingPosY,\n          }) &&\n          piece.type === PieceType.ROOK\n        ) {\n          piece.position.x = 5;\n          piece.hasMoved = true;\n        }\n      } else if (castling.side === \"left\") {\n        if (\n          samePosition(piece.position, {\n            x: tempKingPosX - 4,\n            y: tempKingPosY,\n          }) &&\n          piece.type === PieceType.ROOK\n        ) {\n          piece.position.x = 3;\n          piece.hasMoved = true;\n        }\n      }\n      if (samePosition(piece.position, grabPosition)) {\n        piece.position.x = x;\n        piece.position.y = y;\n        results.push(piece);\n      }\n      if (!samePosition(piece.position, { x, y })) {\n        if (piece.type === PieceType.PAWN) {\n          piece.enPassant = false;\n        }\n        results.push(piece);\n      }\n\n      return results;\n    }, [] as Piece[]);\n  }\n}\n",{"ruleId":"117","replacedBy":"118"},{"ruleId":"119","replacedBy":"120"},{"ruleId":"121","severity":1,"message":"122","line":18,"column":8,"nodeType":"123","messageId":"124","endLine":18,"endColumn":24},{"ruleId":"121","severity":1,"message":"125","line":23,"column":10,"nodeType":"123","messageId":"124","endLine":23,"endColumn":15},{"ruleId":"121","severity":1,"message":"126","line":23,"column":17,"nodeType":"123","messageId":"124","endLine":23,"endColumn":25},{"ruleId":"121","severity":1,"message":"127","line":24,"column":10,"nodeType":"123","messageId":"124","endLine":24,"endColumn":22},{"ruleId":"121","severity":1,"message":"128","line":24,"column":24,"nodeType":"123","messageId":"124","endLine":24,"endColumn":39},{"ruleId":"121","severity":1,"message":"129","line":25,"column":10,"nodeType":"123","messageId":"124","endLine":25,"endColumn":19},{"ruleId":"121","severity":1,"message":"130","line":25,"column":21,"nodeType":"123","messageId":"124","endLine":25,"endColumn":33},{"ruleId":"121","severity":1,"message":"131","line":34,"column":9,"nodeType":"123","messageId":"124","endLine":34,"endColumn":15},{"ruleId":"121","severity":1,"message":"132","line":245,"column":11,"nodeType":"123","messageId":"124","endLine":245,"endColumn":21},{"ruleId":"133","severity":1,"message":"134","line":336,"column":11,"nodeType":"135","endLine":339,"endColumn":13},{"ruleId":"133","severity":1,"message":"134","line":340,"column":11,"nodeType":"135","endLine":343,"endColumn":13},{"ruleId":"133","severity":1,"message":"134","line":344,"column":11,"nodeType":"135","endLine":347,"endColumn":13},{"ruleId":"133","severity":1,"message":"134","line":348,"column":11,"nodeType":"135","endLine":351,"endColumn":13},{"ruleId":"121","severity":1,"message":"136","line":1,"column":10,"nodeType":"123","messageId":"124","endLine":1,"endColumn":13},{"ruleId":"121","severity":1,"message":"137","line":8,"column":3,"nodeType":"123","messageId":"124","endLine":8,"endColumn":7},{"ruleId":"138","severity":1,"message":"139","line":129,"column":33,"nodeType":"140","messageId":"141","endLine":129,"endColumn":35},{"ruleId":"138","severity":1,"message":"139","line":153,"column":29,"nodeType":"140","messageId":"141","endLine":153,"endColumn":31},{"ruleId":"121","severity":1,"message":"142","line":225,"column":7,"nodeType":"123","messageId":"124","endLine":225,"endColumn":8},{"ruleId":"121","severity":1,"message":"143","line":1,"column":17,"nodeType":"123","messageId":"124","endLine":1,"endColumn":26},{"ruleId":"121","severity":1,"message":"137","line":8,"column":3,"nodeType":"123","messageId":"124","endLine":8,"endColumn":7},{"ruleId":"121","severity":1,"message":"144","line":12,"column":3,"nodeType":"123","messageId":"124","endLine":12,"endColumn":11},{"ruleId":"121","severity":1,"message":"145","line":13,"column":3,"nodeType":"123","messageId":"124","endLine":13,"endColumn":13},{"ruleId":"121","severity":1,"message":"146","line":14,"column":3,"nodeType":"123","messageId":"124","endLine":14,"endColumn":13},{"ruleId":"121","severity":1,"message":"147","line":15,"column":3,"nodeType":"123","messageId":"124","endLine":15,"endColumn":11},{"ruleId":"121","severity":1,"message":"148","line":16,"column":3,"nodeType":"123","messageId":"124","endLine":16,"endColumn":12},{"ruleId":"121","severity":1,"message":"149","line":17,"column":3,"nodeType":"123","messageId":"124","endLine":17,"endColumn":11},{"ruleId":"150","severity":1,"message":"151","line":43,"column":24,"nodeType":"152","messageId":"153","endLine":43,"endColumn":26},{"ruleId":"150","severity":1,"message":"151","line":56,"column":30,"nodeType":"152","messageId":"153","endLine":56,"endColumn":32},{"ruleId":"154","severity":1,"message":"155","line":89,"column":19,"nodeType":"156","messageId":"157","endLine":91,"endColumn":6},{"ruleId":"154","severity":1,"message":"158","line":90,"column":8,"nodeType":"156","messageId":"157","endLine":90,"endColumn":61},{"ruleId":"154","severity":1,"message":"155","line":97,"column":19,"nodeType":"156","messageId":"157","endLine":99,"endColumn":8},{"ruleId":"154","severity":1,"message":"158","line":98,"column":10,"nodeType":"156","messageId":"157","endLine":98,"endColumn":64},{"ruleId":"138","severity":1,"message":"139","line":110,"column":39,"nodeType":"140","messageId":"141","endLine":110,"endColumn":41},{"ruleId":"138","severity":1,"message":"139","line":147,"column":39,"nodeType":"140","messageId":"141","endLine":147,"endColumn":41},{"ruleId":"154","severity":1,"message":"159","line":186,"column":22,"nodeType":"156","messageId":"157","endLine":186,"endColumn":46},{"ruleId":"121","severity":1,"message":"160","line":2,"column":8,"nodeType":"123","messageId":"124","endLine":2,"endColumn":15},"no-native-reassign",["161"],"no-negated-in-lhs",["162"],"@typescript-eslint/no-unused-vars","'OnDropObservable' is defined but never used.","Identifier","unusedVar","'first' is assigned a value but never used.","'setFirst' is assigned a value but never used.","'engineToPlay' is assigned a value but never used.","'setEngineToPlay' is assigned a value but never used.","'checkmate' is assigned a value but never used.","'setCheckmate' is assigned a value but never used.","'engine' is assigned a value but never used.","'changeTurn' is assigned a value but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","'off' is defined but never used.","'Move' is defined but never used.","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","'p' is assigned a value but never used.","'PieceType' is defined but never used.","'pawnMove' is defined but never used.","'knightMove' is defined but never used.","'bishopMove' is defined but never used.","'rookMove' is defined but never used.","'queenMove' is defined but never used.","'kingMove' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","@typescript-eslint/consistent-type-assertions","Use 'as AlphaBetaMove' instead of '<AlphaBetaMove>'.","TSTypeAssertion","as","Use 'as unknown' instead of '<unknown>'.","Use 'as Position' instead of '<Position>'.","'Referee' is defined but never used.","no-global-assign","no-unsafe-negation"]