[{"/home/fredericksimard/Dev/Chess-Engine2.0/src/index.tsx":"1","/home/fredericksimard/Dev/Chess-Engine2.0/src/reportWebVitals.ts":"2","/home/fredericksimard/Dev/Chess-Engine2.0/src/App.tsx":"3","/home/fredericksimard/Dev/Chess-Engine2.0/src/components/Chessboard/Chessboard.tsx":"4","/home/fredericksimard/Dev/Chess-Engine2.0/src/Constants.ts":"5","/home/fredericksimard/Dev/Chess-Engine2.0/src/components/Chessboard/ChessboardHelper.ts":"6","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/Referee.ts":"7","/home/fredericksimard/Dev/Chess-Engine2.0/src/Engine/Engine.ts":"8","/home/fredericksimard/Dev/Chess-Engine2.0/src/Engine/OnDropObservable.ts":"9","/home/fredericksimard/Dev/Chess-Engine2.0/src/components/Tile/Tile.tsx":"10","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/index.ts":"11","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/PawnRules.ts":"12","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/BishopRules.ts":"13","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/KnightRules.ts":"14","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/RookRules.ts":"15","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/QueenRules.ts":"16","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/KingRules.ts":"17","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/GeneralRules.ts":"18"},{"size":500,"mtime":1649013223260,"results":"19","hashOfConfig":"20"},{"size":425,"mtime":1649013223261,"results":"21","hashOfConfig":"20"},{"size":215,"mtime":1649013223260,"results":"22","hashOfConfig":"20"},{"size":11222,"mtime":1649045494555,"results":"23","hashOfConfig":"20"},{"size":5612,"mtime":1649036140425,"results":"24","hashOfConfig":"20"},{"size":1370,"mtime":1649013223260,"results":"25","hashOfConfig":"20"},{"size":10323,"mtime":1649037587125,"results":"26","hashOfConfig":"20"},{"size":5683,"mtime":1649036140425,"results":"27","hashOfConfig":"20"},{"size":240,"mtime":1649013223260,"results":"28","hashOfConfig":"20"},{"size":547,"mtime":1649013223260,"results":"29","hashOfConfig":"20"},{"size":178,"mtime":1649013223261,"results":"30","hashOfConfig":"20"},{"size":1763,"mtime":1649013223261,"results":"31","hashOfConfig":"20"},{"size":2836,"mtime":1649013223261,"results":"32","hashOfConfig":"20"},{"size":1182,"mtime":1649013223261,"results":"33","hashOfConfig":"20"},{"size":1397,"mtime":1649013223261,"results":"34","hashOfConfig":"20"},{"size":1009,"mtime":1649013223261,"results":"35","hashOfConfig":"20"},{"size":1008,"mtime":1649013223261,"results":"36","hashOfConfig":"20"},{"size":896,"mtime":1649013223261,"results":"37","hashOfConfig":"20"},{"filePath":"38","messages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},"1aku2hd",{"filePath":"41","messages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"43","messages":"44","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"45","messages":"46","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47"},{"filePath":"48","messages":"49","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"50","messages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"40"},{"filePath":"53","messages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"40"},{"filePath":"56","messages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58","usedDeprecatedRules":"40"},{"filePath":"59","messages":"60","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"61","messages":"62","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"63","messages":"64","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"65","messages":"66","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67","usedDeprecatedRules":"40"},{"filePath":"68","messages":"69","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"70","messages":"71","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"72","messages":"73","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"74","messages":"75","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"76","messages":"77","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"78","messages":"79","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},"/home/fredericksimard/Dev/Chess-Engine2.0/src/index.tsx",[],["80","81"],"/home/fredericksimard/Dev/Chess-Engine2.0/src/reportWebVitals.ts",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/App.tsx",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/components/Chessboard/Chessboard.tsx",["82","83","84","85","86","87","88"],"import { useRef, useState } from \"react\";\nimport \"./Chessboard.css\";\nimport Tile from \"../Tile/Tile\";\nimport Referee from \"../../referee/Referee\";\nimport Engine from \"../../Engine/Engine\";\nimport {\n  VERTICAL_AXIS,\n  HORIZONTAL_AXIS,\n  GRID_SIZE,\n  Piece,\n  PieceType,\n  TeamType,\n  initialBoardState,\n  Position,\n  samePosition,\n} from \"../../Constants\";\nimport React from \"react\";\nimport OnDropObservable from \"../../Engine/OnDropObservable\";\nimport ChessboardHelper from \"./ChessboardHelper\";\n\nexport default function Chessboard() {\n  // When it's true it is white to play\n  const [first, setFirst] = useState(0);\n  const [engineToPlay, setEngineToPlay] = useState(false);\n  const [turn, setTurn] = useState(true);\n  const [activePiece, setActivePiece] = useState<HTMLElement | null>(null);\n  const [promotionPawn, setPromotionPawn] = useState<Piece>();\n  const [grabPosition, setGrabPosition] = useState<Position>({ x: -1, y: -1 });\n  const [pieces, setPieces] = useState<Piece[]>(initialBoardState);\n  const chessboardRef = useRef<HTMLDivElement>(null);\n  const modalRef = useRef<HTMLDivElement>(null);\n  const referee = new Referee();\n  const engine = new Engine(referee);\n  const chessboardHelper = new ChessboardHelper();\n  const onDropObservable = new OnDropObservable(() => {\n    setPieces(engine.play(pieces));\n  });\n\n  function grabPiece(e: React.MouseEvent) {\n    const element = e.target as HTMLElement;\n    const chessboard = chessboardRef.current;\n    if (element.classList.contains(\"chess-piece\") && chessboard) {\n      const grabX = Math.floor((e.clientX - chessboard.offsetLeft) / GRID_SIZE);\n      const grabY = Math.abs(\n        Math.ceil((e.clientY - chessboard.offsetTop - 800) / GRID_SIZE)\n      );\n      setGrabPosition({ x: grabX, y: grabY });\n\n      const x = e.clientX - GRID_SIZE / 2;\n      const y = e.clientY - GRID_SIZE / 2;\n      element.style.position = \"absolute\";\n      element.style.left = `${x}px`;\n      element.style.top = `${y}px`;\n\n      setActivePiece(element);\n    }\n  }\n\n  function movePiece(e: React.MouseEvent) {\n    const chessboard = chessboardRef.current;\n    if (activePiece && chessboard) {\n      const minX = chessboard.offsetLeft - 25;\n      const minY = chessboard.offsetTop - 25;\n      const maxX = chessboard.offsetLeft + chessboard.clientWidth - 75;\n      const maxY = chessboard.offsetTop + chessboard.clientHeight - 75;\n      const x = e.clientX - 50;\n      const y = e.clientY - 50;\n      activePiece.style.position = \"absolute\";\n\n      //If x is smaller than minimum amount\n      if (x < minX) {\n        activePiece.style.left = `${minX}px`;\n      }\n      //If x is bigger than maximum amount\n      else if (x > maxX) {\n        activePiece.style.left = `${maxX}px`;\n      }\n      //If x is in the constraints\n      else {\n        activePiece.style.left = `${x}px`;\n      }\n\n      //If y is smaller than minimum amount\n      if (y < minY) {\n        activePiece.style.top = `${minY}px`;\n      }\n      //If y is bigger than maximum amount\n      else if (y > maxY) {\n        activePiece.style.top = `${maxY}px`;\n      }\n      //If y is in the constraints\n      else {\n        activePiece.style.top = `${y}px`;\n      }\n    }\n  }\n\n  function dropPiece(e: React.MouseEvent) {\n    let changeTurn = false;\n    const chessboard = chessboardRef.current;\n    let castling = { legal: false, side: \"\" };\n    let tempKingPosX = -1;\n    let tempKingPosY = -1;\n\n    if (activePiece && chessboard) {\n      const x = Math.floor((e.clientX - chessboard.offsetLeft) / GRID_SIZE);\n      const y = Math.abs(\n        Math.ceil((e.clientY - chessboard.offsetTop - 800) / GRID_SIZE)\n      );\n\n      const currentPiece = pieces.find((p) =>\n        samePosition(p.position, grabPosition)\n      );\n\n      // King special rules\n      if (currentPiece) {\n        if (currentPiece.type === PieceType.KING) {\n          tempKingPosX = currentPiece.position.x;\n          tempKingPosY = currentPiece.position.y;\n\n          // Check if castling possible\n          if (currentPiece.position.y === y) {\n            if (!currentPiece.hasMoved) {\n              if (currentPiece.position.x === x + 2) {\n                if (referee.checkCastling(currentPiece, pieces, 2, turn)) {\n                  castling = { legal: true, side: \"left\" };\n                }\n              } else if (currentPiece.position.x === x - 2) {\n                if (referee.checkCastling(currentPiece, pieces, -2, turn)) {\n                  castling = { legal: true, side: \"right\" };\n                }\n              }\n            }\n          }\n        }\n\n        const validMove = referee.isValidMove(\n          grabPosition,\n          { x, y },\n          currentPiece.type,\n          currentPiece.team,\n          pieces,\n          turn,\n          0\n        );\n        // console.log('thisiisisis ', validMove)\n\n        if (!validMove) {\n          if (currentPiece.type === PieceType.KING) {\n            currentPiece.position.x = tempKingPosX;\n            currentPiece.position.y = tempKingPosY;\n          }\n        }\n\n        const isEnPassantMove = referee.isEnPassantMove(\n          grabPosition,\n          { x, y },\n          currentPiece.type,\n          currentPiece.team,\n          pieces\n        );\n\n        const pawnDirection = currentPiece.team === TeamType.OUR ? 1 : -1;\n\n        if (castling.legal) {\n          chessboardHelper.castlingReduce(\n            pieces,\n            castling,\n            tempKingPosX,\n            tempKingPosY,\n            grabPosition,\n            x,\n            y\n          );\n        } else if (isEnPassantMove) {\n\n          const updatePieces: Piece[] = [];\n\n          pieces.forEach((piece) => {\n            if (samePosition(piece.position, grabPosition)) {\n              piece.enPassant = false;\n              piece.position.x = x;\n              piece.position.y = y;\n              updatePieces.push(Object.assign({}, piece));\n            } else if (\n              !samePosition(piece.position, { x, y: y - pawnDirection })\n            ) {\n              if (piece.type === PieceType.PAWN) {\n                piece.enPassant = false;\n              }\n              updatePieces.push(Object.assign({}, piece));\n            } else {\n              let idx = pieces.indexOf(piece);\n              if (idx !== -1) {\n                pieces.splice(idx, 1);\n              }\n            }\n          })\n\n          setPieces(updatePieces);\n          changeTurn = true;\n        } else if (validMove) {\n          //UPDATES THE PIECE POSITION\n          //AND IF A PIECE IS ATTACKED, REMOVES IT\n\n          const updatePieces: Piece[] = [];\n\n          pieces.forEach((piece) => {\n            if (samePosition(piece.position, grabPosition)) {\n              // console.log('the piece', piece)\n              //SPECIAL MOVE\n              piece.enPassant =\n                Math.abs(grabPosition.y - y) === 2 &&\n                piece.type === PieceType.PAWN;\n\n              piece.position.x = x;\n              piece.position.y = y;\n\n              if (\n                piece.type === PieceType.ROOK ||\n                piece.type === PieceType.KING\n              ) {\n                piece.hasMoved = true;\n              }\n\n              let promotionRow = piece.team === TeamType.OUR ? 7 : 0;\n\n              if (y === promotionRow && piece.type === PieceType.PAWN) {\n                modalRef.current?.classList.remove(\"hidden\");\n                setPromotionPawn(piece);\n              }\n              updatePieces.push(Object.assign({}, piece));\n            } else if (!samePosition(piece.position, { x, y })) {\n              if (piece.type === PieceType.PAWN) {\n                piece.enPassant = false;\n              }\n              updatePieces.push(Object.assign({}, piece));\n            } else {\n              let idx = pieces.indexOf(piece);\n              if (idx !== -1) {\n                pieces.splice(idx, 1);\n              }\n            }\n          });\n\n          setPieces(updatePieces);\n          changeTurn = true;\n        } else {\n          //RESETS THE PIECE POSITION\n          activePiece.style.position = \"relative\";\n          activePiece.style.removeProperty(\"top\");\n          activePiece.style.removeProperty(\"left\");\n        }\n      }\n      setActivePiece(null);\n    }\n    const stateOfGame = referee.isCheckmate(pieces, !turn);\n    if (stateOfGame === \"true\") {\n      console.log(\"checkmate!!!! \");\n    } else if (stateOfGame === \"stalemate\") {\n      console.log(\"stalemate\");\n    } else if (stateOfGame === \"draw\") {\n      console.log(\"draw by unsuficient material\");\n    }\n    setTurn(true);\n    if (changeTurn) {\n      setEngineToPlay(true);\n      // engine.play(pieces)\n      // setTimeout(() => {engine.play(pieces)}, 100)\n\n      onDropObservable.subscribe(dropPiece);\n    }\n\n  }\n\n  function promotePawn(pieceType: PieceType) {\n    if (promotionPawn === undefined) {\n      return;\n    }\n\n    const updatedPieces = pieces.reduce((results, piece) => {\n      if (samePosition(piece.position, promotionPawn.position)) {\n        piece.type = pieceType;\n        const teamType = piece.team === TeamType.OUR ? \"w\" : \"b\";\n        let image = \"\";\n        switch (pieceType) {\n          case PieceType.ROOK: {\n            image = \"rook\";\n            break;\n          }\n          case PieceType.BISHOP: {\n            image = \"bishop\";\n            break;\n          }\n          case PieceType.KNIGHT: {\n            image = \"knight\";\n            break;\n          }\n          case PieceType.QUEEN: {\n            image = \"queen\";\n            break;\n          }\n        }\n        piece.image = `assets/images/${image}_${teamType}.png`;\n      }\n      results.push(piece);\n      return results;\n    }, [] as Piece[]);\n\n    setPieces(updatedPieces);\n\n    modalRef.current?.classList.add(\"hidden\");\n  }\n\n  function promotionTeamType() {\n    return promotionPawn?.team === TeamType.OUR ? \"w\" : \"b\";\n  }\n\n  let board = [];\n\n  for (let j = VERTICAL_AXIS.length - 1; j >= 0; j--) {\n    for (let i = 0; i < HORIZONTAL_AXIS.length; i++) {\n      const number = j + i + 2;\n      const piece = pieces.find((p) =>\n        samePosition(p.position, { x: i, y: j })\n      );\n      let image = piece ? piece.image : undefined;\n\n      board.push(<Tile key={`${j},${i}`} image={image} number={number} />);\n    }\n  }\n\n  return (\n    <>\n      <div id=\"pawn-promotion-modal\" className=\"hidden\" ref={modalRef}>\n        <div className=\"modal-body\">\n          <img\n            onClick={() => promotePawn(PieceType.ROOK)}\n            src={`/assets/images/rook_${promotionTeamType()}.png`}\n          />\n          <img\n            onClick={() => promotePawn(PieceType.BISHOP)}\n            src={`/assets/images/bishop_${promotionTeamType()}.png`}\n          />\n          <img\n            onClick={() => promotePawn(PieceType.KNIGHT)}\n            src={`/assets/images/knight_${promotionTeamType()}.png`}\n          />\n          <img\n            onClick={() => promotePawn(PieceType.QUEEN)}\n            src={`/assets/images/queen_${promotionTeamType()}.png`}\n          />\n        </div>\n      </div>\n      <div\n        onMouseMove={(e) => movePiece(e)}\n        onMouseDown={(e) => grabPiece(e)}\n        onMouseUp={(e) => dropPiece(e)}\n        id=\"chessboard\"\n        ref={chessboardRef}\n      >\n        {board}\n      </div>\n    </>\n  );\n}\n","/home/fredericksimard/Dev/Chess-Engine2.0/src/Constants.ts",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/components/Chessboard/ChessboardHelper.ts",["89"],"import { Piece, PieceType, Position, samePosition } from \"../../Constants\";\nimport Referee from \"../../referee/Referee\";\n\nexport default class ChessboardHelper {\n  castlingReduce(\n    pieces: Piece[],\n    castling: any,\n    tempKingPosX: number,\n    tempKingPosY: number,\n    grabPosition: Position,\n    x: number,\n    y: number\n  ) {\n    pieces.reduce((results, piece) => {\n      if (castling.side === \"right\") {\n        if (\n          samePosition(piece.position, {\n            x: tempKingPosX + 3,\n            y: tempKingPosY,\n          }) &&\n          piece.type === PieceType.ROOK\n        ) {\n          piece.position.x = 5;\n          piece.hasMoved = true;\n        }\n      } else if (castling.side === \"left\") {\n        if (\n          samePosition(piece.position, {\n            x: tempKingPosX - 4,\n            y: tempKingPosY,\n          }) &&\n          piece.type === PieceType.ROOK\n        ) {\n          piece.position.x = 3;\n          piece.hasMoved = true;\n        }\n      }\n      if (samePosition(piece.position, grabPosition)) {\n        piece.position.x = x;\n        piece.position.y = y;\n        results.push(piece);\n      }\n      if (!samePosition(piece.position, { x, y })) {\n        if (piece.type === PieceType.PAWN) {\n          piece.enPassant = false;\n        }\n        results.push(piece);\n      }\n\n      return results;\n    }, [] as Piece[]);\n  }\n}\n","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/Referee.ts",["90","91","92","93","94"],"import { off } from \"process\";\nimport {\n  PieceType,\n  TeamType,\n  Piece,\n  Position,\n  samePosition,\n  Move,\n} from \"../Constants\";\n\nimport {\n  pawnMove,\n  knightMove,\n  bishopMove,\n  rookMove,\n  queenMove,\n  kingMove,\n} from \"./rules\";\n\nexport default class Referee {\n  state: Piece[] = [];\n\n  isEnPassantMove(\n    initialPosition: Position,\n    desiredPosition: Position,\n    type: PieceType,\n    team: TeamType,\n    boardState: Piece[]\n  ) {\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n\n    if (type === PieceType.PAWN) {\n      if (\n        (desiredPosition.x - initialPosition.x === -1 ||\n          desiredPosition.x - initialPosition.x === 1) &&\n        desiredPosition.y - initialPosition.y === pawnDirection\n      ) {\n        const piece = boardState.find(\n          (p) =>\n            p.position.x === desiredPosition.x &&\n            p.position.y === desiredPosition.y - pawnDirection &&\n            p.enPassant\n        );\n        if (piece) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  //TODO\n  //Add check!\n  //Add checkmate!\n  //Add stalemate!\n  isValidMove(\n    initialPosition: Position,\n    desiredPosition: Position,\n    type: PieceType,\n    team: TeamType,\n    boardState: Piece[],\n    turn: boolean,\n    depth: number\n  ) {\n    let validMove = false;\n    let tempBoard: Piece[];\n    let kingPrevPos = {\n      x: 10,\n      y: 10,\n    };\n\n    if (this.checkTurn(team, turn)) {\n      // console.log(\"checkturn\");\n      return false;\n    }\n\n    switch (type) {\n      case PieceType.PAWN:\n        validMove = pawnMove(\n          initialPosition,\n          desiredPosition,\n          team,\n          boardState\n        );\n        break;\n      case PieceType.KNIGHT:\n        validMove = knightMove(\n          initialPosition,\n          desiredPosition,\n          team,\n          boardState\n        );\n        break;\n      case PieceType.BISHOP:\n        validMove = bishopMove(\n          initialPosition,\n          desiredPosition,\n          team,\n          boardState\n        );\n        break;\n      case PieceType.ROOK:\n        validMove = rookMove(\n          initialPosition,\n          desiredPosition,\n          team,\n          boardState\n        );\n        break;\n      case PieceType.QUEEN:\n        validMove = queenMove(\n          initialPosition,\n          desiredPosition,\n          team,\n          boardState\n        );\n        break;\n      case PieceType.KING:\n        validMove = kingMove(\n          initialPosition,\n          desiredPosition,\n          team,\n          boardState\n        );\n\n        if (depth < 1 && validMove) {\n          tempBoard = JSON.parse(JSON.stringify(boardState));\n          tempBoard.map((piece) => {\n            if (samePosition(piece.position, initialPosition)) {\n              piece.position = desiredPosition;\n              kingPrevPos.x = piece.position.x;\n              kingPrevPos.y = piece.position.y;\n              if (\n                this.kingMoveToInvalidSquare(\n                  team,\n                  desiredPosition,\n                  tempBoard,\n                  turn,\n                  depth\n                )\n              ) {\n                validMove = false;\n              }\n            }\n          });\n        }\n        break;\n    }\n\n    if (validMove && depth < 1) {\n      tempBoard = JSON.parse(JSON.stringify(boardState));\n      tempBoard.map((piece) => {\n        if (samePosition(piece.position, initialPosition)) {\n          piece.position = desiredPosition;\n          tempBoard = this.removeCapturedPiece(piece, tempBoard);\n          if (this.isInCheck(tempBoard, turn)) {\n            validMove = false;\n          }\n        }\n      });\n    }\n    return validMove;\n  }\n\n  removeCapturedPiece(piece: Piece, pieces: Piece[]) {\n    let p = null;\n    for (const piec of pieces) {\n      if (\n        samePosition(piec.position, piece.position) &&\n        piece.team.valueOf() !== piec.team.valueOf()\n      ) {\n        p = piec;\n      }\n    }\n    if (p !== null) {\n      // console.log(\"captured piece \", p);\n      let idx = pieces.indexOf(p);\n      if (idx !== -1) {\n        pieces.splice(idx, 1);\n      }\n    }\n    return pieces;\n  }\n\n  isInCheck(pieces: Piece[], turn: boolean) {\n    // Find the king\n    let king = this.getKing(pieces, turn);\n    for (const piece of pieces) {\n      // Check if enemy pieces can check the king\n      if (piece?.team !== king?.team) {\n        if (king !== null) {\n          if (\n            this.isValidMove(\n              piece.position,\n              { x: king.position.x, y: king.position.y },\n              piece.type,\n              piece.team,\n              pieces,\n              !turn,\n              1\n            )\n          ) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  kingMoveToInvalidSquare(\n    team: TeamType,\n    desiredPosition: Position,\n    board: Piece[],\n    turn: boolean,\n    depth: number\n  ): boolean {\n    const currentTurn = !turn;\n\n    const king = this.getKing(board, turn);\n    let p = null;\n    if (king !== null) {\n      p = this.removeCapturedPiece(king, board);\n    }\n\n    for (const piece of board) {\n      if (piece.team !== team && depth < 1) {\n        if (\n          this.isValidMove(\n            piece.position,\n            desiredPosition,\n            piece.type,\n            piece.team,\n            board,\n            currentTurn,\n            depth + 1\n          )\n        ) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  checkCastling(king: Piece, pieces: Piece[], side: number, turn: boolean) {\n    const row = king.position.y;\n    let rook = null;\n\n    // Castling right\n    if (side < 0) {\n      for (const piece of pieces) {\n        // Check if attacks between rook and king\n        if (piece.team !== king.team) {\n          for (let i = 0; i < 3; i++) {\n            if (\n              this.isValidMove(\n                piece.position,\n                { x: king.position.x + i, y: king.position.y },\n                piece.type,\n                piece.team,\n                pieces,\n                !turn,\n                1\n              )\n            ) {\n              return false;\n            }\n          }\n        }\n\n        if (piece.type === PieceType.ROOK && piece.team === king.team) {\n          if (piece.position.x === 7) {\n            rook = piece;\n            if (piece.hasMoved) {\n              return false;\n            }\n          }\n        }\n\n        // Check if pieces between rook and king\n        if (samePosition(piece.position, { x: 5, y: row })) {\n          return false;\n        } else if (samePosition(piece.position, { x: 6, y: row })) {\n          return false;\n        }\n      }\n    }\n    // Castling left\n    else {\n      for (const piece of pieces) {\n        if (piece.team !== king.team) {\n          for (let i = 0; i < 4; i++) {\n            if (\n              this.isValidMove(\n                piece.position,\n                { x: king.position.x - i, y: king.position.y },\n                piece.type,\n                piece.team,\n                pieces,\n                !turn,\n                1\n              )\n            ) {\n              return false;\n            }\n          }\n        }\n\n        if (piece.type === PieceType.ROOK && piece.team === king.team) {\n          if (piece.position.x === 0) {\n            rook = piece;\n            if (piece.hasMoved) {\n              return false;\n            }\n          }\n        }\n\n        if (samePosition(piece.position, { x: 1, y: row })) {\n          return false;\n        } else if (samePosition(piece.position, { x: 2, y: row })) {\n          return false;\n        } else if (samePosition(piece.position, { x: 3, y: row })) {\n          return false;\n        }\n      }\n    }\n\n    // If rook is not null, it means we found the rook.\n    if (rook !== null) {\n      return true;\n    }\n    return false;\n  }\n\n  getKing(pieces: Piece[], turn: boolean) {\n    for (const piece of pieces) {\n      if (piece?.type === PieceType.KING) {\n        if (turn) {\n          if (piece.team === TeamType.OUR) {\n            return piece;\n          }\n        } else {\n          if (piece.team === TeamType.OPPONENT) {\n            return piece;\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  checkTurn(team: TeamType, turn: boolean) {\n    if (\n      (team === TeamType.OUR && turn === false) ||\n      (team === TeamType.OPPONENT && turn === true)\n    ) {\n      // If true then it is NOT your turn\n      return true;\n    }\n  }\n\n  isCheckmate(pieces: Piece[], turn: boolean) {\n    // Potential draw\n    if (pieces.length === 2) {\n      return \"draw\";\n    } else if (pieces.length < 5) {\n      let countWhite = 0;\n      let countBlack = 0;\n      for (const piece of pieces) {\n        if (piece.type !== PieceType.KING) {\n          if (\n            piece.type !== PieceType.PAWN &&\n            piece.type !== PieceType.QUEEN &&\n            piece.type !== PieceType.ROOK\n          ) {\n            if (piece.team === TeamType.OUR) {\n              countWhite++;\n            } else {\n              countBlack++;\n            }\n          }\n        }\n      }\n      if (countWhite < 2) {\n        return \"draw\";\n      } else if (countBlack < 2) {\n        return \"draw\";\n      }\n    }\n\n    for (const piece of pieces) {\n      // white's turn\n      if (turn && piece.team === TeamType.OUR) {\n        for (let i = 0; i < 8; i++) {\n          for (let j = 0; j < 8; j++) {\n            if (\n              this.isValidMove(\n                piece.position,\n                { x: i, y: j },\n                piece.type,\n                piece.team,\n                pieces,\n                turn,\n                0\n              )\n            ) {\n              return \"false\";\n            }\n          }\n        }\n      } else if (!turn && piece.team === TeamType.OPPONENT) {\n        for (let i = 0; i < 8; i++) {\n          for (let j = 0; j < 8; j++) {\n            if (\n              this.isValidMove(\n                piece.position,\n                { x: i, y: j },\n                piece.type,\n                piece.team,\n                pieces,\n                turn,\n                0\n              )\n            ) {\n              return \"false\";\n            }\n          }\n        }\n      }\n    }\n\n    if (this.isInCheck(pieces, turn)) {\n      return \"true\";\n    } else {\n      return \"stalemate\";\n    }\n  }\n}\n","/home/fredericksimard/Dev/Chess-Engine2.0/src/Engine/Engine.ts",["95","96","97","98","99","100","101","102","103","104","105","106","107","108"],"import Referee from \"../referee/Referee\";\nimport {\n  PieceType,\n  TeamType,\n  Piece,\n  Position,\n  samePosition,\n  Move,\n} from \"../Constants\";\n\nimport {\n  pawnMove,\n  knightMove,\n  bishopMove,\n  rookMove,\n  queenMove,\n  kingMove,\n} from \"../referee/rules\";\n\ninterface AlphaBetaMove {\n  piece: Piece;\n  position: Position;\n  value: number;\n}\n\nexport default class Engine {\n  ref: Referee;\n\n  constructor(ref: Referee) {\n    this.ref = ref;\n  }\n\n  play(pieces: Piece[]): Piece[] {\n    const bestMove = this.alphaBeta(\n      // bestMove,\n      pieces,\n      2,\n      -Math.pow(10, 1000),\n      Math.pow(10, 1000),\n      TeamType.OPPONENT\n    );\n    console.log(\"the best move is: \", bestMove);\n    for (const piece of pieces) {\n      if (piece.position === bestMove.piece.position) {\n        piece.position = bestMove.position;\n        this.ref.removeCapturedPiece(piece, pieces);\n        return pieces;\n      }\n    }\n    return pieces;\n  }\n\n  alphaBeta(\n    // bestMove: AlphaBetaMove,\n    pieces: Piece[],\n    depth: number,\n    a: number,\n    b: number,\n    maximizingPlayer: TeamType\n  ): AlphaBetaMove {\n    let bestMov = <AlphaBetaMove>(\n      (<unknown>{ piece: null, position: null, value: null })\n    );\n    if (depth === 0) {\n      const value = this.evaluation(pieces);\n      // if (value === 1) {\n      //   // console.log(\"knight took ? \", pieces[1]);\n      // }\n      let _eval = <AlphaBetaMove>(\n        (<unknown>{ piece: null, position: null, value: value })\n      );\n      // console.log(\"the eval is: \", _eval);\n      return _eval;\n    }\n    if (maximizingPlayer === TeamType.OPPONENT) {\n      let maxEval = -1 * Math.pow(10, 1000); // -Infinite\n      for (const piece of pieces) {\n        if (piece.team === TeamType.OPPONENT) {\n          const moves = this.getMoves(piece, pieces, true);\n          for (const move of moves) {\n            let tempPieces = JSON.parse(JSON.stringify(pieces));\n            tempPieces.map((p: Piece) => {\n              if (samePosition(p.position, piece.position)) {\n                p.position = move;\n                tempPieces = this.ref.removeCapturedPiece(p, tempPieces);\n              }\n            });\n            const newEval = this.alphaBeta(\n              tempPieces,\n              depth - 1,\n              a,\n              b,\n              TeamType.OUR\n            );\n            if (maxEval < newEval.value) {\n              console.log(\"found a better move \", move);\n              bestMov = newEval;\n              bestMov.piece = piece;\n              bestMov.position = move;\n              maxEval = newEval.value;\n            }\n            // maxEval = Math.max(maxEval, newEval.value);\n            a = Math.max(a, newEval.value);\n            if (b <= a) {\n              break;\n            }\n          }\n        }\n      }\n      return bestMov;\n    } else {\n      let minEval = Math.pow(10, 1000);\n      for (const piece of pieces) {\n        if (piece.team === TeamType.OUR) {\n          const moves = this.getMoves(piece, pieces, false);\n          for (const move of moves) {\n            let tempPieces = JSON.parse(JSON.stringify(pieces));\n            tempPieces.map((p: Piece) => {\n              if (samePosition(p.position, piece.position)) {\n                p.position = move;\n                // console.log(\"before capture: \", tempPieces.length);\n                tempPieces = this.ref.removeCapturedPiece(p, tempPieces);\n                // console.log(\"after capture \", tempPieces.length);\n              }\n            });\n            const newEval = this.alphaBeta(\n              tempPieces,\n              depth - 1,\n              a,\n              b,\n              TeamType.OPPONENT\n            );\n            if (minEval > newEval.value) {\n              // console.log(\"found a better move\");\n              bestMov = newEval;\n              bestMov.piece = piece;\n              bestMov.position = move;\n              minEval = newEval.value;\n            }\n            b = Math.min(b, newEval.value);\n            if (b <= a) {\n              break;\n            }\n          }\n        }\n      }\n      return bestMov;\n    }\n  }\n\n  getMoves(piece: Piece, pieces: Piece[], turn: boolean): Position[] {\n    let movesList: Position[];\n    movesList = [];\n    for (let i = 0; i < 8; i++) {\n      for (let j = 0; j < 8; j++) {\n        const move = <Position>{ x: i, y: j };\n        if (\n          this.ref.isValidMove(\n            piece.position,\n            move,\n            piece.type,\n            piece.team,\n            pieces,\n            !turn,\n            0\n          )\n        ) {\n          movesList.push({ x: i, y: j });\n        }\n      }\n    }\n    return movesList;\n  }\n\n  evaluation(pieces: Piece[]): number {\n    let counter = 0;\n    for (const piece of pieces) {\n      if (piece.team === TeamType.OPPONENT) {\n        switch (piece.type) {\n          case PieceType.BISHOP:\n            counter += 3;\n            break;\n          case PieceType.KNIGHT:\n            counter += 3;\n            break;\n          case PieceType.PAWN:\n            counter += 1;\n            break;\n          case PieceType.QUEEN:\n            counter += 9;\n            break;\n          case PieceType.ROOK:\n            counter += 5;\n            break;\n        }\n      } else {\n        switch (piece.type) {\n          case PieceType.BISHOP:\n            counter -= 3;\n            break;\n          case PieceType.KNIGHT:\n            counter -= 3;\n            break;\n          case PieceType.PAWN:\n            counter -= 1;\n            break;\n          case PieceType.QUEEN:\n            counter -= 9;\n            break;\n          case PieceType.ROOK:\n            counter -= 5;\n            break;\n        }\n      }\n    }\n    return counter;\n  }\n}\n","/home/fredericksimard/Dev/Chess-Engine2.0/src/Engine/OnDropObservable.ts",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/components/Tile/Tile.tsx",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/index.ts",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/PawnRules.ts",["109"],"import { Piece, PieceType, Position, TeamType } from \"../../Constants\";\nimport { tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const pawnMove = (initialPosition: Position, desiredPosition: Position, team: TeamType, boardState: Piece[]): boolean => {\n    const specialRow = team === TeamType.OUR ? 1 : 6;\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n\n    // if(test) console.log('works')\n\n    //MOVEMENT LOGIC\n    if (\n      initialPosition.x === desiredPosition.x &&\n      initialPosition.y === specialRow &&\n      desiredPosition.y - initialPosition.y === 2 * pawnDirection\n    ) {\n      if (\n        !tileIsOccupied(desiredPosition, boardState) &&\n        !tileIsOccupied(\n          { x: desiredPosition.x, y: desiredPosition.y - pawnDirection },\n          boardState\n        )\n      ) {\n\n        return true;\n      }\n    } else if (\n      initialPosition.x === desiredPosition.x &&\n      desiredPosition.y - initialPosition.y === pawnDirection\n    ) {\n      if (!tileIsOccupied(desiredPosition, boardState)) {\n        // console.log('ffffffffffffffffff')\n        return true;\n      }\n    }\n    //ATTACK LOGIC\n    else if (\n      desiredPosition.x - initialPosition.x === -1 &&\n      desiredPosition.y - initialPosition.y === pawnDirection\n    ) {\n      //ATTACK IN UPPER OR BOTTOM LEFT CORNER\n      if (tileIsOccupiedByOpponent(desiredPosition, boardState, team)) {\n        return true;\n      }\n    } else if (\n      desiredPosition.x - initialPosition.x === 1 &&\n      desiredPosition.y - initialPosition.y === pawnDirection\n    ) {\n      //ATTACK IN THE UPPER OR BOTTOM RIGHT CORNER\n      if (tileIsOccupiedByOpponent(desiredPosition, boardState, team)) {    \n        return true;\n      }\n    }\n\n    return false;\n  }","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/BishopRules.ts",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/KnightRules.ts",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/RookRules.ts",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/QueenRules.ts",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/KingRules.ts",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/GeneralRules.ts",[],{"ruleId":"110","replacedBy":"111"},{"ruleId":"112","replacedBy":"113"},{"ruleId":"114","severity":1,"message":"115","line":23,"column":10,"nodeType":"116","messageId":"117","endLine":23,"endColumn":15},{"ruleId":"114","severity":1,"message":"118","line":23,"column":17,"nodeType":"116","messageId":"117","endLine":23,"endColumn":25},{"ruleId":"114","severity":1,"message":"119","line":24,"column":10,"nodeType":"116","messageId":"117","endLine":24,"endColumn":22},{"ruleId":"120","severity":1,"message":"121","line":337,"column":11,"nodeType":"122","endLine":340,"endColumn":13},{"ruleId":"120","severity":1,"message":"121","line":341,"column":11,"nodeType":"122","endLine":344,"endColumn":13},{"ruleId":"120","severity":1,"message":"121","line":345,"column":11,"nodeType":"122","endLine":348,"endColumn":13},{"ruleId":"120","severity":1,"message":"121","line":349,"column":11,"nodeType":"122","endLine":352,"endColumn":13},{"ruleId":"114","severity":1,"message":"123","line":2,"column":8,"nodeType":"116","messageId":"117","endLine":2,"endColumn":15},{"ruleId":"114","severity":1,"message":"124","line":1,"column":10,"nodeType":"116","messageId":"117","endLine":1,"endColumn":13},{"ruleId":"114","severity":1,"message":"125","line":8,"column":3,"nodeType":"116","messageId":"117","endLine":8,"endColumn":7},{"ruleId":"126","severity":1,"message":"127","line":129,"column":33,"nodeType":"128","messageId":"129","endLine":129,"endColumn":35},{"ruleId":"126","severity":1,"message":"127","line":153,"column":29,"nodeType":"128","messageId":"129","endLine":153,"endColumn":31},{"ruleId":"114","severity":1,"message":"130","line":224,"column":7,"nodeType":"116","messageId":"117","endLine":224,"endColumn":8},{"ruleId":"114","severity":1,"message":"125","line":8,"column":3,"nodeType":"116","messageId":"117","endLine":8,"endColumn":7},{"ruleId":"114","severity":1,"message":"131","line":12,"column":3,"nodeType":"116","messageId":"117","endLine":12,"endColumn":11},{"ruleId":"114","severity":1,"message":"132","line":13,"column":3,"nodeType":"116","messageId":"117","endLine":13,"endColumn":13},{"ruleId":"114","severity":1,"message":"133","line":14,"column":3,"nodeType":"116","messageId":"117","endLine":14,"endColumn":13},{"ruleId":"114","severity":1,"message":"134","line":15,"column":3,"nodeType":"116","messageId":"117","endLine":15,"endColumn":11},{"ruleId":"114","severity":1,"message":"135","line":16,"column":3,"nodeType":"116","messageId":"117","endLine":16,"endColumn":12},{"ruleId":"114","severity":1,"message":"136","line":17,"column":3,"nodeType":"116","messageId":"117","endLine":17,"endColumn":11},{"ruleId":"137","severity":1,"message":"138","line":61,"column":19,"nodeType":"139","messageId":"140","endLine":63,"endColumn":6},{"ruleId":"137","severity":1,"message":"141","line":62,"column":8,"nodeType":"139","messageId":"140","endLine":62,"endColumn":61},{"ruleId":"137","severity":1,"message":"138","line":69,"column":19,"nodeType":"139","messageId":"140","endLine":71,"endColumn":8},{"ruleId":"137","severity":1,"message":"141","line":70,"column":10,"nodeType":"139","messageId":"140","endLine":70,"endColumn":64},{"ruleId":"126","severity":1,"message":"127","line":82,"column":39,"nodeType":"128","messageId":"129","endLine":82,"endColumn":41},{"ruleId":"126","severity":1,"message":"127","line":118,"column":39,"nodeType":"128","messageId":"129","endLine":118,"endColumn":41},{"ruleId":"137","severity":1,"message":"142","line":156,"column":22,"nodeType":"139","messageId":"140","endLine":156,"endColumn":46},{"ruleId":"114","severity":1,"message":"143","line":1,"column":17,"nodeType":"116","messageId":"117","endLine":1,"endColumn":26},"no-native-reassign",["144"],"no-negated-in-lhs",["145"],"@typescript-eslint/no-unused-vars","'first' is assigned a value but never used.","Identifier","unusedVar","'setFirst' is assigned a value but never used.","'engineToPlay' is assigned a value but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","'Referee' is defined but never used.","'off' is defined but never used.","'Move' is defined but never used.","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","'p' is assigned a value but never used.","'pawnMove' is defined but never used.","'knightMove' is defined but never used.","'bishopMove' is defined but never used.","'rookMove' is defined but never used.","'queenMove' is defined but never used.","'kingMove' is defined but never used.","@typescript-eslint/consistent-type-assertions","Use 'as AlphaBetaMove' instead of '<AlphaBetaMove>'.","TSTypeAssertion","as","Use 'as unknown' instead of '<unknown>'.","Use 'as Position' instead of '<Position>'.","'PieceType' is defined but never used.","no-global-assign","no-unsafe-negation"]