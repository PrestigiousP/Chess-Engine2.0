[{"/home/fredericksimard/Dev/Chess-Engine2.0/src/index.tsx":"1","/home/fredericksimard/Dev/Chess-Engine2.0/src/reportWebVitals.ts":"2","/home/fredericksimard/Dev/Chess-Engine2.0/src/App.tsx":"3","/home/fredericksimard/Dev/Chess-Engine2.0/src/components/Chessboard/Chessboard.tsx":"4","/home/fredericksimard/Dev/Chess-Engine2.0/src/Constants.ts":"5","/home/fredericksimard/Dev/Chess-Engine2.0/src/components/Chessboard/ChessboardHelper.ts":"6","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/Referee.ts":"7","/home/fredericksimard/Dev/Chess-Engine2.0/src/Engine/Engine.ts":"8","/home/fredericksimard/Dev/Chess-Engine2.0/src/Engine/OnDropObservable.ts":"9","/home/fredericksimard/Dev/Chess-Engine2.0/src/components/Tile/Tile.tsx":"10","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/index.ts":"11","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/PawnRules.ts":"12","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/BishopRules.ts":"13","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/KnightRules.ts":"14","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/RookRules.ts":"15","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/QueenRules.ts":"16","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/KingRules.ts":"17","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/GeneralRules.ts":"18"},{"size":500,"mtime":1649013223260,"results":"19","hashOfConfig":"20"},{"size":425,"mtime":1649013223261,"results":"21","hashOfConfig":"20"},{"size":215,"mtime":1649013223260,"results":"22","hashOfConfig":"20"},{"size":11247,"mtime":1649047352429,"results":"23","hashOfConfig":"20"},{"size":5612,"mtime":1649036140425,"results":"24","hashOfConfig":"20"},{"size":1370,"mtime":1649013223260,"results":"25","hashOfConfig":"20"},{"size":10381,"mtime":1649048501547,"results":"26","hashOfConfig":"20"},{"size":6857,"mtime":1649048930391,"results":"27","hashOfConfig":"20"},{"size":240,"mtime":1649013223260,"results":"28","hashOfConfig":"20"},{"size":547,"mtime":1649013223260,"results":"29","hashOfConfig":"20"},{"size":178,"mtime":1649013223261,"results":"30","hashOfConfig":"20"},{"size":1763,"mtime":1649013223261,"results":"31","hashOfConfig":"20"},{"size":2836,"mtime":1649013223261,"results":"32","hashOfConfig":"20"},{"size":1182,"mtime":1649013223261,"results":"33","hashOfConfig":"20"},{"size":1397,"mtime":1649013223261,"results":"34","hashOfConfig":"20"},{"size":1009,"mtime":1649013223261,"results":"35","hashOfConfig":"20"},{"size":1008,"mtime":1649013223261,"results":"36","hashOfConfig":"20"},{"size":896,"mtime":1649013223261,"results":"37","hashOfConfig":"20"},{"filePath":"38","messages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},"1aku2hd",{"filePath":"41","messages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"43","messages":"44","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"45","messages":"46","errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"40"},{"filePath":"48","messages":"49","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"50","messages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"40"},{"filePath":"53","messages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"40"},{"filePath":"56","messages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"58","messages":"59","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"60","messages":"61","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"62","messages":"63","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"64","messages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"66","usedDeprecatedRules":"40"},{"filePath":"67","messages":"68","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"69","messages":"70","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"71","messages":"72","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"73","messages":"74","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"75","messages":"76","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"77","messages":"78","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},"/home/fredericksimard/Dev/Chess-Engine2.0/src/index.tsx",[],["79","80"],"/home/fredericksimard/Dev/Chess-Engine2.0/src/reportWebVitals.ts",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/App.tsx",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/components/Chessboard/Chessboard.tsx",["81","82","83","84","85","86","87","88","89","90"],"import { useRef, useState } from \"react\";\nimport \"./Chessboard.css\";\nimport Tile from \"../Tile/Tile\";\nimport Referee from \"../../referee/Referee\";\nimport Engine from \"../../Engine/Engine\";\nimport {\n  VERTICAL_AXIS,\n  HORIZONTAL_AXIS,\n  GRID_SIZE,\n  Piece,\n  PieceType,\n  TeamType,\n  initialBoardState,\n  Position,\n  samePosition,\n} from \"../../Constants\";\nimport React from \"react\";\nimport OnDropObservable from \"../../Engine/OnDropObservable\";\nimport ChessboardHelper from \"./ChessboardHelper\";\n\nexport default function Chessboard() {\n  // When it's true it is white to play\n  const [first, setFirst] = useState(0);\n  const [engineToPlay, setEngineToPlay] = useState(false);\n  const [checkmate, setCheckmate] = useState(false);\n  const [turn, setTurn] = useState(true);\n  const [activePiece, setActivePiece] = useState<HTMLElement | null>(null);\n  const [promotionPawn, setPromotionPawn] = useState<Piece>();\n  const [grabPosition, setGrabPosition] = useState<Position>({ x: -1, y: -1 });\n  const [pieces, setPieces] = useState<Piece[]>(initialBoardState);\n  const chessboardRef = useRef<HTMLDivElement>(null);\n  const modalRef = useRef<HTMLDivElement>(null);\n  const referee = new Referee();\n  const engine = new Engine(referee);\n  const chessboardHelper = new ChessboardHelper();\n  const onDropObservable = new OnDropObservable(() => {\n    setPieces(engine.play(pieces));\n  });\n\n  function grabPiece(e: React.MouseEvent) {\n    const element = e.target as HTMLElement;\n    const chessboard = chessboardRef.current;\n    if (element.classList.contains(\"chess-piece\") && chessboard) {\n      const grabX = Math.floor((e.clientX - chessboard.offsetLeft) / GRID_SIZE);\n      const grabY = Math.abs(\n        Math.ceil((e.clientY - chessboard.offsetTop - 800) / GRID_SIZE)\n      );\n      setGrabPosition({ x: grabX, y: grabY });\n\n      const x = e.clientX - GRID_SIZE / 2;\n      const y = e.clientY - GRID_SIZE / 2;\n      element.style.position = \"absolute\";\n      element.style.left = `${x}px`;\n      element.style.top = `${y}px`;\n\n      setActivePiece(element);\n    }\n  }\n\n  function movePiece(e: React.MouseEvent) {\n    const chessboard = chessboardRef.current;\n    if (activePiece && chessboard) {\n      const minX = chessboard.offsetLeft - 25;\n      const minY = chessboard.offsetTop - 25;\n      const maxX = chessboard.offsetLeft + chessboard.clientWidth - 75;\n      const maxY = chessboard.offsetTop + chessboard.clientHeight - 75;\n      const x = e.clientX - 50;\n      const y = e.clientY - 50;\n      activePiece.style.position = \"absolute\";\n\n      //If x is smaller than minimum amount\n      if (x < minX) {\n        activePiece.style.left = `${minX}px`;\n      }\n      //If x is bigger than maximum amount\n      else if (x > maxX) {\n        activePiece.style.left = `${maxX}px`;\n      }\n      //If x is in the constraints\n      else {\n        activePiece.style.left = `${x}px`;\n      }\n\n      //If y is smaller than minimum amount\n      if (y < minY) {\n        activePiece.style.top = `${minY}px`;\n      }\n      //If y is bigger than maximum amount\n      else if (y > maxY) {\n        activePiece.style.top = `${maxY}px`;\n      }\n      //If y is in the constraints\n      else {\n        activePiece.style.top = `${y}px`;\n      }\n    }\n  }\n\n  function dropPiece(e: React.MouseEvent) {\n    let changeTurn = false;\n    const chessboard = chessboardRef.current;\n    let castling = { legal: false, side: \"\" };\n    let tempKingPosX = -1;\n    let tempKingPosY = -1;\n\n    if (activePiece && chessboard) {\n      const x = Math.floor((e.clientX - chessboard.offsetLeft) / GRID_SIZE);\n      const y = Math.abs(\n        Math.ceil((e.clientY - chessboard.offsetTop - 800) / GRID_SIZE)\n      );\n\n      const currentPiece = pieces.find((p) =>\n        samePosition(p.position, grabPosition)\n      );\n\n      // King special rules\n      if (currentPiece) {\n        if (currentPiece.type === PieceType.KING) {\n          tempKingPosX = currentPiece.position.x;\n          tempKingPosY = currentPiece.position.y;\n\n          // Check if castling possible\n          if (currentPiece.position.y === y) {\n            if (!currentPiece.hasMoved) {\n              if (currentPiece.position.x === x + 2) {\n                if (referee.checkCastling(currentPiece, pieces, 2, turn)) {\n                  castling = { legal: true, side: \"left\" };\n                }\n              } else if (currentPiece.position.x === x - 2) {\n                if (referee.checkCastling(currentPiece, pieces, -2, turn)) {\n                  castling = { legal: true, side: \"right\" };\n                }\n              }\n            }\n          }\n        }\n\n        const validMove = referee.isValidMove(\n          grabPosition,\n          { x, y },\n          currentPiece.type,\n          currentPiece.team,\n          pieces,\n          turn,\n          0\n        );\n        // console.log('thisiisisis ', validMove)\n\n        if (!validMove) {\n          if (currentPiece.type === PieceType.KING) {\n            currentPiece.position.x = tempKingPosX;\n            currentPiece.position.y = tempKingPosY;\n          }\n        }\n\n        const isEnPassantMove = referee.isEnPassantMove(\n          grabPosition,\n          { x, y },\n          currentPiece.type,\n          currentPiece.team,\n          pieces\n        );\n\n        const pawnDirection = currentPiece.team === TeamType.OUR ? 1 : -1;\n\n        if (castling.legal) {\n          chessboardHelper.castlingReduce(\n            pieces,\n            castling,\n            tempKingPosX,\n            tempKingPosY,\n            grabPosition,\n            x,\n            y\n          );\n        } else if (isEnPassantMove) {\n\n          const updatePieces: Piece[] = [];\n\n          pieces.forEach((piece) => {\n            if (samePosition(piece.position, grabPosition)) {\n              piece.enPassant = false;\n              piece.position.x = x;\n              piece.position.y = y;\n              updatePieces.push(Object.assign({}, piece));\n            } else if (\n              !samePosition(piece.position, { x, y: y - pawnDirection })\n            ) {\n              if (piece.type === PieceType.PAWN) {\n                piece.enPassant = false;\n              }\n              updatePieces.push(Object.assign({}, piece));\n            } else {\n              let idx = pieces.indexOf(piece);\n              if (idx !== -1) {\n                pieces.splice(idx, 1);\n              }\n            }\n          })\n\n          setPieces(updatePieces);\n          changeTurn = true;\n        } else if (validMove) {\n          //UPDATES THE PIECE POSITION\n          //AND IF A PIECE IS ATTACKED, REMOVES IT\n\n          const updatePieces: Piece[] = [];\n\n          pieces.forEach((piece) => {\n            if (samePosition(piece.position, grabPosition)) {\n              piece.enPassant =\n                Math.abs(grabPosition.y - y) === 2 &&\n                piece.type === PieceType.PAWN;\n\n              piece.position.x = x;\n              piece.position.y = y;\n\n              if (\n                piece.type === PieceType.ROOK ||\n                piece.type === PieceType.KING\n              ) {\n                piece.hasMoved = true;\n              }\n\n              let promotionRow = piece.team === TeamType.OUR ? 7 : 0;\n\n              if (y === promotionRow && piece.type === PieceType.PAWN) {\n                modalRef.current?.classList.remove(\"hidden\");\n                setPromotionPawn(piece);\n              }\n              updatePieces.push(Object.assign({}, piece));\n            } else if (!samePosition(piece.position, { x, y })) {\n              if (piece.type === PieceType.PAWN) {\n                piece.enPassant = false;\n              }\n              updatePieces.push(Object.assign({}, piece));\n            } else {\n              let idx = pieces.indexOf(piece);\n              if (idx !== -1) {\n                pieces.splice(idx, 1);\n              }\n            }\n          });\n\n          setPieces(updatePieces);\n          changeTurn = true;\n        } else {\n          //RESETS THE PIECE POSITION\n          activePiece.style.position = \"relative\";\n          activePiece.style.removeProperty(\"top\");\n          activePiece.style.removeProperty(\"left\");\n        }\n      }\n      setActivePiece(null);\n    }\n    const stateOfGame = referee.isCheckmate(pieces, !turn);\n    if (stateOfGame === \"true\") {\n      console.log(\"checkmate!!!! \");\n      return;\n    } else if (stateOfGame === \"stalemate\") {\n      console.log(\"stalemate\");\n    } else if (stateOfGame === \"draw\") {\n      console.log(\"draw by unsuficient material\");\n    }\n    setTurn(true);\n    if (changeTurn) {\n    //   setEngineToPlay(true);\n    //   // engine.play(pieces)\n    //   // setTimeout(() => {engine.play(pieces)}, 100)\n\n      onDropObservable.subscribe(dropPiece);\n          //setTurn(!turn);\n    }\n  }\n\n  function promotePawn(pieceType: PieceType) {\n    if (promotionPawn === undefined) {\n      return;\n    }\n\n    const updatedPieces = pieces.reduce((results, piece) => {\n      if (samePosition(piece.position, promotionPawn.position)) {\n        piece.type = pieceType;\n        const teamType = piece.team === TeamType.OUR ? \"w\" : \"b\";\n        let image = \"\";\n        switch (pieceType) {\n          case PieceType.ROOK: {\n            image = \"rook\";\n            break;\n          }\n          case PieceType.BISHOP: {\n            image = \"bishop\";\n            break;\n          }\n          case PieceType.KNIGHT: {\n            image = \"knight\";\n            break;\n          }\n          case PieceType.QUEEN: {\n            image = \"queen\";\n            break;\n          }\n        }\n        piece.image = `assets/images/${image}_${teamType}.png`;\n      }\n      results.push(piece);\n      return results;\n    }, [] as Piece[]);\n\n    setPieces(updatedPieces);\n\n    modalRef.current?.classList.add(\"hidden\");\n  }\n\n  function promotionTeamType() {\n    return promotionPawn?.team === TeamType.OUR ? \"w\" : \"b\";\n  }\n\n  let board = [];\n\n  for (let j = VERTICAL_AXIS.length - 1; j >= 0; j--) {\n    for (let i = 0; i < HORIZONTAL_AXIS.length; i++) {\n      const number = j + i + 2;\n      const piece = pieces.find((p) =>\n        samePosition(p.position, { x: i, y: j })\n      );\n      let image = piece ? piece.image : undefined;\n\n      board.push(<Tile key={`${j},${i}`} image={image} number={number} />);\n    }\n  }\n\n  return (\n    <>\n      <div id=\"pawn-promotion-modal\" className=\"hidden\" ref={modalRef}>\n        <div className=\"modal-body\">\n          <img\n            onClick={() => promotePawn(PieceType.ROOK)}\n            src={`/assets/images/rook_${promotionTeamType()}.png`}\n          />\n          <img\n            onClick={() => promotePawn(PieceType.BISHOP)}\n            src={`/assets/images/bishop_${promotionTeamType()}.png`}\n          />\n          <img\n            onClick={() => promotePawn(PieceType.KNIGHT)}\n            src={`/assets/images/knight_${promotionTeamType()}.png`}\n          />\n          <img\n            onClick={() => promotePawn(PieceType.QUEEN)}\n            src={`/assets/images/queen_${promotionTeamType()}.png`}\n          />\n        </div>\n      </div>\n      <div\n        onMouseMove={(e) => movePiece(e)}\n        onMouseDown={(e) => grabPiece(e)}\n        onMouseUp={(e) => dropPiece(e)}\n        id=\"chessboard\"\n        ref={chessboardRef}\n      >\n        {board}\n      </div>\n    </>\n  );\n}\n","/home/fredericksimard/Dev/Chess-Engine2.0/src/Constants.ts",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/components/Chessboard/ChessboardHelper.ts",["91"],"import { Piece, PieceType, Position, samePosition } from \"../../Constants\";\nimport Referee from \"../../referee/Referee\";\n\nexport default class ChessboardHelper {\n  castlingReduce(\n    pieces: Piece[],\n    castling: any,\n    tempKingPosX: number,\n    tempKingPosY: number,\n    grabPosition: Position,\n    x: number,\n    y: number\n  ) {\n    pieces.reduce((results, piece) => {\n      if (castling.side === \"right\") {\n        if (\n          samePosition(piece.position, {\n            x: tempKingPosX + 3,\n            y: tempKingPosY,\n          }) &&\n          piece.type === PieceType.ROOK\n        ) {\n          piece.position.x = 5;\n          piece.hasMoved = true;\n        }\n      } else if (castling.side === \"left\") {\n        if (\n          samePosition(piece.position, {\n            x: tempKingPosX - 4,\n            y: tempKingPosY,\n          }) &&\n          piece.type === PieceType.ROOK\n        ) {\n          piece.position.x = 3;\n          piece.hasMoved = true;\n        }\n      }\n      if (samePosition(piece.position, grabPosition)) {\n        piece.position.x = x;\n        piece.position.y = y;\n        results.push(piece);\n      }\n      if (!samePosition(piece.position, { x, y })) {\n        if (piece.type === PieceType.PAWN) {\n          piece.enPassant = false;\n        }\n        results.push(piece);\n      }\n\n      return results;\n    }, [] as Piece[]);\n  }\n}\n","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/Referee.ts",["92","93","94","95","96"],"import { off } from \"process\";\nimport {\n  PieceType,\n  TeamType,\n  Piece,\n  Position,\n  samePosition,\n  Move,\n} from \"../Constants\";\n\nimport {\n  pawnMove,\n  knightMove,\n  bishopMove,\n  rookMove,\n  queenMove,\n  kingMove,\n} from \"./rules\";\n\nexport default class Referee {\n  state: Piece[] = [];\n\n  isEnPassantMove(\n    initialPosition: Position,\n    desiredPosition: Position,\n    type: PieceType,\n    team: TeamType,\n    boardState: Piece[]\n  ) {\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n\n    if (type === PieceType.PAWN) {\n      if (\n        (desiredPosition.x - initialPosition.x === -1 ||\n          desiredPosition.x - initialPosition.x === 1) &&\n        desiredPosition.y - initialPosition.y === pawnDirection\n      ) {\n        const piece = boardState.find(\n          (p) =>\n            p.position.x === desiredPosition.x &&\n            p.position.y === desiredPosition.y - pawnDirection &&\n            p.enPassant\n        );\n        if (piece) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  //TODO\n  //Add check!\n  //Add checkmate!\n  //Add stalemate!\n  isValidMove(\n    initialPosition: Position,\n    desiredPosition: Position,\n    type: PieceType,\n    team: TeamType,\n    boardState: Piece[],\n    turn: boolean,\n    depth: number\n  ) {\n    let validMove = false;\n    let tempBoard: Piece[];\n    let kingPrevPos = {\n      x: 10,\n      y: 10,\n    };\n\n    if (this.checkTurn(team, turn)) {\n      // console.log(\"checkturn\");\n      return false;\n    }\n\n    switch (type) {\n      case PieceType.PAWN:\n        validMove = pawnMove(\n          initialPosition,\n          desiredPosition,\n          team,\n          boardState\n        );\n        break;\n      case PieceType.KNIGHT:\n        validMove = knightMove(\n          initialPosition,\n          desiredPosition,\n          team,\n          boardState\n        );\n        break;\n      case PieceType.BISHOP:\n        validMove = bishopMove(\n          initialPosition,\n          desiredPosition,\n          team,\n          boardState\n        );\n        break;\n      case PieceType.ROOK:\n        validMove = rookMove(\n          initialPosition,\n          desiredPosition,\n          team,\n          boardState\n        );\n        break;\n      case PieceType.QUEEN:\n        validMove = queenMove(\n          initialPosition,\n          desiredPosition,\n          team,\n          boardState\n        );\n        break;\n      case PieceType.KING:\n        validMove = kingMove(\n          initialPosition,\n          desiredPosition,\n          team,\n          boardState\n        );\n\n        if (depth < 1 && validMove) {\n          tempBoard = JSON.parse(JSON.stringify(boardState));\n          tempBoard.map((piece) => {\n            if (samePosition(piece.position, initialPosition)) {\n              piece.position = desiredPosition;\n              kingPrevPos.x = piece.position.x;\n              kingPrevPos.y = piece.position.y;\n              if (\n                this.kingMoveToInvalidSquare(\n                  team,\n                  desiredPosition,\n                  tempBoard,\n                  turn,\n                  depth\n                )\n              ) {\n                validMove = false;\n              }\n            }\n          });\n        }\n        break;\n    }\n\n    if (validMove && depth < 1) {\n      tempBoard = JSON.parse(JSON.stringify(boardState));\n      tempBoard.map((piece) => {\n        if (samePosition(piece.position, initialPosition)) {\n          piece.position = desiredPosition;\n          tempBoard = this.removeCapturedPiece(piece, tempBoard);\n          if (this.isInCheck(tempBoard, turn)) {\n            validMove = false;\n          }\n        }\n      });\n    }\n    return validMove;\n  }\n\n  removeCapturedPiece(piece: Piece, pieces: Piece[]) {\n    let p = null;\n    for (const piec of pieces) {\n      if (\n        samePosition(piec.position, piece.position) &&\n        piece.team.valueOf() !== piec.team.valueOf()\n      ) {\n        p = piec;\n      }\n    }\n    if (p !== null) {\n      // console.log(\"captured piece \", p);\n      let idx = pieces.indexOf(p);\n      if (idx !== -1) {\n        // console.log(\"p jamais Ã©gale \", idx);\n        pieces.splice(idx, 1);\n      }\n    }\n    return pieces;\n  }\n\n  isInCheck(pieces: Piece[], turn: boolean) {\n    // Find the king\n    let king = this.getKing(pieces, turn);\n    for (const piece of pieces) {\n      // Check if enemy pieces can check the king\n      if (piece?.team !== king?.team) {\n        if (king !== null) {\n          if (\n            this.isValidMove(\n              piece.position,\n              { x: king.position.x, y: king.position.y },\n              piece.type,\n              piece.team,\n              pieces,\n              !turn,\n              1\n            )\n          ) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  kingMoveToInvalidSquare(\n    team: TeamType,\n    desiredPosition: Position,\n    board: Piece[],\n    turn: boolean,\n    depth: number\n  ): boolean {\n    const currentTurn = !turn;\n\n    const king = this.getKing(board, turn);\n    let p = null;\n    if (king !== null) {\n      p = this.removeCapturedPiece(king, board);\n    }\n\n    for (const piece of board) {\n      if (piece.team !== team && depth < 1) {\n        if (\n          this.isValidMove(\n            piece.position,\n            desiredPosition,\n            piece.type,\n            piece.team,\n            board,\n            currentTurn,\n            depth + 1\n          )\n        ) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  checkCastling(king: Piece, pieces: Piece[], side: number, turn: boolean) {\n    const row = king.position.y;\n    let rook = null;\n\n    // Castling right\n    if (side < 0) {\n      for (const piece of pieces) {\n        // Check if attacks between rook and king\n        if (piece.team !== king.team) {\n          for (let i = 0; i < 3; i++) {\n            if (\n              this.isValidMove(\n                piece.position,\n                { x: king.position.x + i, y: king.position.y },\n                piece.type,\n                piece.team,\n                pieces,\n                !turn,\n                1\n              )\n            ) {\n              return false;\n            }\n          }\n        }\n\n        if (piece.type === PieceType.ROOK && piece.team === king.team) {\n          if (piece.position.x === 7) {\n            rook = piece;\n            if (piece.hasMoved) {\n              return false;\n            }\n          }\n        }\n\n        // Check if pieces between rook and king\n        if (samePosition(piece.position, { x: 5, y: row })) {\n          return false;\n        } else if (samePosition(piece.position, { x: 6, y: row })) {\n          return false;\n        }\n      }\n    }\n    // Castling left\n    else {\n      for (const piece of pieces) {\n        if (piece.team !== king.team) {\n          for (let i = 0; i < 4; i++) {\n            if (\n              this.isValidMove(\n                piece.position,\n                { x: king.position.x - i, y: king.position.y },\n                piece.type,\n                piece.team,\n                pieces,\n                !turn,\n                1\n              )\n            ) {\n              return false;\n            }\n          }\n        }\n\n        if (piece.type === PieceType.ROOK && piece.team === king.team) {\n          if (piece.position.x === 0) {\n            rook = piece;\n            if (piece.hasMoved) {\n              return false;\n            }\n          }\n        }\n\n        if (samePosition(piece.position, { x: 1, y: row })) {\n          return false;\n        } else if (samePosition(piece.position, { x: 2, y: row })) {\n          return false;\n        } else if (samePosition(piece.position, { x: 3, y: row })) {\n          return false;\n        }\n      }\n    }\n\n    // If rook is not null, it means we found the rook.\n    if (rook !== null) {\n      return true;\n    }\n    return false;\n  }\n\n  getKing(pieces: Piece[], turn: boolean) {\n    for (const piece of pieces) {\n      if (piece?.type === PieceType.KING) {\n        if (turn) {\n          if (piece.team === TeamType.OUR) {\n            return piece;\n          }\n        } else {\n          if (piece.team === TeamType.OPPONENT) {\n            return piece;\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  checkTurn(team: TeamType, turn: boolean) {\n    if (\n      (team === TeamType.OUR && turn === false) ||\n      (team === TeamType.OPPONENT && turn === true)\n    ) {\n      // If true then it is NOT your turn\n      return true;\n    }\n  }\n\n  isCheckmate(pieces: Piece[], turn: boolean) : string {\n    // Potential draw\n    if (pieces.length === 2) {\n      return \"draw\";\n    } else if (pieces.length < 5) {\n      let countWhite = 0;\n      let countBlack = 0;\n      for (const piece of pieces) {\n        if (piece.type !== PieceType.KING) {\n          if (\n            piece.type !== PieceType.PAWN &&\n            piece.type !== PieceType.QUEEN &&\n            piece.type !== PieceType.ROOK\n          ) {\n            if (piece.team === TeamType.OUR) {\n              countWhite++;\n            } else {\n              countBlack++;\n            }\n          }\n        }\n      }\n      if (countWhite < 2) {\n        return \"draw\";\n      } else if (countBlack < 2) {\n        return \"draw\";\n      }\n    }\n\n    for (const piece of pieces) {\n      // white's turn\n      if (turn && piece.team === TeamType.OUR) {\n        for (let i = 0; i < 8; i++) {\n          for (let j = 0; j < 8; j++) {\n            if (\n              this.isValidMove(\n                piece.position,\n                { x: i, y: j },\n                piece.type,\n                piece.team,\n                pieces,\n                turn,\n                0\n              )\n            ) {\n              return \"false\";\n            }\n          }\n        }\n      } else if (!turn && piece.team === TeamType.OPPONENT) {\n        for (let i = 0; i < 8; i++) {\n          for (let j = 0; j < 8; j++) {\n            if (\n              this.isValidMove(\n                piece.position,\n                { x: i, y: j },\n                piece.type,\n                piece.team,\n                pieces,\n                turn,\n                0\n              )\n            ) {\n              return \"false\";\n            }\n          }\n        }\n      }\n    }\n\n    if (this.isInCheck(pieces, turn)) {\n      return \"true\";\n    } else {\n      return \"stalemate\";\n    }\n  }\n}\n","/home/fredericksimard/Dev/Chess-Engine2.0/src/Engine/Engine.ts",["97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112"],"/home/fredericksimard/Dev/Chess-Engine2.0/src/Engine/OnDropObservable.ts",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/components/Tile/Tile.tsx",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/index.ts",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/PawnRules.ts",["113"],"import { Piece, PieceType, Position, TeamType } from \"../../Constants\";\nimport { tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const pawnMove = (initialPosition: Position, desiredPosition: Position, team: TeamType, boardState: Piece[]): boolean => {\n    const specialRow = team === TeamType.OUR ? 1 : 6;\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n\n    // if(test) console.log('works')\n\n    //MOVEMENT LOGIC\n    if (\n      initialPosition.x === desiredPosition.x &&\n      initialPosition.y === specialRow &&\n      desiredPosition.y - initialPosition.y === 2 * pawnDirection\n    ) {\n      if (\n        !tileIsOccupied(desiredPosition, boardState) &&\n        !tileIsOccupied(\n          { x: desiredPosition.x, y: desiredPosition.y - pawnDirection },\n          boardState\n        )\n      ) {\n\n        return true;\n      }\n    } else if (\n      initialPosition.x === desiredPosition.x &&\n      desiredPosition.y - initialPosition.y === pawnDirection\n    ) {\n      if (!tileIsOccupied(desiredPosition, boardState)) {\n        // console.log('ffffffffffffffffff')\n        return true;\n      }\n    }\n    //ATTACK LOGIC\n    else if (\n      desiredPosition.x - initialPosition.x === -1 &&\n      desiredPosition.y - initialPosition.y === pawnDirection\n    ) {\n      //ATTACK IN UPPER OR BOTTOM LEFT CORNER\n      if (tileIsOccupiedByOpponent(desiredPosition, boardState, team)) {\n        return true;\n      }\n    } else if (\n      desiredPosition.x - initialPosition.x === 1 &&\n      desiredPosition.y - initialPosition.y === pawnDirection\n    ) {\n      //ATTACK IN THE UPPER OR BOTTOM RIGHT CORNER\n      if (tileIsOccupiedByOpponent(desiredPosition, boardState, team)) {    \n        return true;\n      }\n    }\n\n    return false;\n  }","/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/BishopRules.ts",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/KnightRules.ts",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/RookRules.ts",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/QueenRules.ts",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/KingRules.ts",[],"/home/fredericksimard/Dev/Chess-Engine2.0/src/referee/rules/GeneralRules.ts",[],{"ruleId":"114","replacedBy":"115"},{"ruleId":"116","replacedBy":"117"},{"ruleId":"118","severity":1,"message":"119","line":23,"column":10,"nodeType":"120","messageId":"121","endLine":23,"endColumn":15},{"ruleId":"118","severity":1,"message":"122","line":23,"column":17,"nodeType":"120","messageId":"121","endLine":23,"endColumn":25},{"ruleId":"118","severity":1,"message":"123","line":24,"column":10,"nodeType":"120","messageId":"121","endLine":24,"endColumn":22},{"ruleId":"118","severity":1,"message":"124","line":24,"column":24,"nodeType":"120","messageId":"121","endLine":24,"endColumn":39},{"ruleId":"118","severity":1,"message":"125","line":25,"column":10,"nodeType":"120","messageId":"121","endLine":25,"endColumn":19},{"ruleId":"118","severity":1,"message":"126","line":25,"column":21,"nodeType":"120","messageId":"121","endLine":25,"endColumn":33},{"ruleId":"127","severity":1,"message":"128","line":337,"column":11,"nodeType":"129","endLine":340,"endColumn":13},{"ruleId":"127","severity":1,"message":"128","line":341,"column":11,"nodeType":"129","endLine":344,"endColumn":13},{"ruleId":"127","severity":1,"message":"128","line":345,"column":11,"nodeType":"129","endLine":348,"endColumn":13},{"ruleId":"127","severity":1,"message":"128","line":349,"column":11,"nodeType":"129","endLine":352,"endColumn":13},{"ruleId":"118","severity":1,"message":"130","line":2,"column":8,"nodeType":"120","messageId":"121","endLine":2,"endColumn":15},{"ruleId":"118","severity":1,"message":"131","line":1,"column":10,"nodeType":"120","messageId":"121","endLine":1,"endColumn":13},{"ruleId":"118","severity":1,"message":"132","line":8,"column":3,"nodeType":"120","messageId":"121","endLine":8,"endColumn":7},{"ruleId":"133","severity":1,"message":"134","line":129,"column":33,"nodeType":"135","messageId":"136","endLine":129,"endColumn":35},{"ruleId":"133","severity":1,"message":"134","line":153,"column":29,"nodeType":"135","messageId":"136","endLine":153,"endColumn":31},{"ruleId":"118","severity":1,"message":"137","line":225,"column":7,"nodeType":"120","messageId":"121","endLine":225,"endColumn":8},{"ruleId":"118","severity":1,"message":"132","line":8,"column":3,"nodeType":"120","messageId":"121","endLine":8,"endColumn":7},{"ruleId":"118","severity":1,"message":"138","line":12,"column":3,"nodeType":"120","messageId":"121","endLine":12,"endColumn":11},{"ruleId":"118","severity":1,"message":"139","line":13,"column":3,"nodeType":"120","messageId":"121","endLine":13,"endColumn":13},{"ruleId":"118","severity":1,"message":"140","line":14,"column":3,"nodeType":"120","messageId":"121","endLine":14,"endColumn":13},{"ruleId":"118","severity":1,"message":"141","line":15,"column":3,"nodeType":"120","messageId":"121","endLine":15,"endColumn":11},{"ruleId":"118","severity":1,"message":"142","line":16,"column":3,"nodeType":"120","messageId":"121","endLine":16,"endColumn":12},{"ruleId":"118","severity":1,"message":"143","line":17,"column":3,"nodeType":"120","messageId":"121","endLine":17,"endColumn":11},{"ruleId":"144","severity":1,"message":"145","line":43,"column":24,"nodeType":"146","messageId":"147","endLine":43,"endColumn":26},{"ruleId":"144","severity":1,"message":"145","line":56,"column":30,"nodeType":"146","messageId":"147","endLine":56,"endColumn":32},{"ruleId":"148","severity":1,"message":"149","line":89,"column":19,"nodeType":"150","messageId":"151","endLine":91,"endColumn":6},{"ruleId":"148","severity":1,"message":"152","line":90,"column":8,"nodeType":"150","messageId":"151","endLine":90,"endColumn":61},{"ruleId":"148","severity":1,"message":"149","line":97,"column":19,"nodeType":"150","messageId":"151","endLine":99,"endColumn":8},{"ruleId":"148","severity":1,"message":"152","line":98,"column":10,"nodeType":"150","messageId":"151","endLine":98,"endColumn":64},{"ruleId":"133","severity":1,"message":"134","line":110,"column":39,"nodeType":"135","messageId":"136","endLine":110,"endColumn":41},{"ruleId":"133","severity":1,"message":"134","line":147,"column":39,"nodeType":"135","messageId":"136","endLine":147,"endColumn":41},{"ruleId":"148","severity":1,"message":"153","line":186,"column":22,"nodeType":"150","messageId":"151","endLine":186,"endColumn":46},{"ruleId":"118","severity":1,"message":"154","line":1,"column":17,"nodeType":"120","messageId":"121","endLine":1,"endColumn":26},"no-native-reassign",["155"],"no-negated-in-lhs",["156"],"@typescript-eslint/no-unused-vars","'first' is assigned a value but never used.","Identifier","unusedVar","'setFirst' is assigned a value but never used.","'engineToPlay' is assigned a value but never used.","'setEngineToPlay' is assigned a value but never used.","'checkmate' is assigned a value but never used.","'setCheckmate' is assigned a value but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","'Referee' is defined but never used.","'off' is defined but never used.","'Move' is defined but never used.","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","'p' is assigned a value but never used.","'pawnMove' is defined but never used.","'knightMove' is defined but never used.","'bishopMove' is defined but never used.","'rookMove' is defined but never used.","'queenMove' is defined but never used.","'kingMove' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","@typescript-eslint/consistent-type-assertions","Use 'as AlphaBetaMove' instead of '<AlphaBetaMove>'.","TSTypeAssertion","as","Use 'as unknown' instead of '<unknown>'.","Use 'as Position' instead of '<Position>'.","'PieceType' is defined but never used.","no-global-assign","no-unsafe-negation"]